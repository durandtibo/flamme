{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A library to generate custom reports of pandas DataFrames.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>flamme</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>flamme</code> to a new version will possibly break any code that was using the old version of <code>flamme</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>flamme</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install flamme\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>flamme</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'flamme[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>flamme</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/flamme.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate flamme\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>flamme</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/analyzer/","title":"analyzer","text":""},{"location":"refs/analyzer/#flamme.analyzer","title":"flamme.analyzer","text":"<p>Contain DataFrame analyzers.</p>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer","title":"flamme.analyzer.BaseAnalyzer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to analyze a DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer.analyze","title":"flamme.analyzer.BaseAnalyzer.analyze","text":"<pre><code>analyze(frame: DataFrame | DataFrame) -&gt; BaseSection\n</code></pre> <p>Analyze the data in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame | DataFrame</code> <p>The DataFrame with the data to analyze.</p> required <p>Returns:</p> Type Description <code>BaseSection</code> <p>The section report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ChoiceAnalyzer","title":"flamme.analyzer.ChoiceAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>selection_fn</code> <code>Callable[[DataFrame], str]</code> <p>Specifies a callable with the selection logic. The callable returns the key of the analyzer to use based on the data in the input DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import (\n...     ChoiceAnalyzer,\n...     FilteredAnalyzer,\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = ChoiceAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()},\n...     selection_fn=lambda frame: \"null\" if frame.isna().values.any() else \"duplicate\",\n... )\n&gt;&gt;&gt; analyzer\nChoiceAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section.__class__.__qualname__\nNullValueSection\n&gt;&gt;&gt; frame = pd.DataFrame({\"col\": np.arange(10)})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section.__class__.__qualname__\nDuplicatedRowSection\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAdvancedAnalyzer","title":"flamme.analyzer.ColumnContinuousAdvancedAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAdvancedAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAdvancedAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAdvancedAnalyzer(column=float, nbins=None, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAnalyzer","title":"flamme.analyzer.ColumnContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q0'</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q1'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAnalyzer(column=float, nbins=None, yscale=auto, xmin=q0, xmax=q1, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousTemporalDriftAnalyzer","title":"flamme.analyzer.ColumnContinuousTemporalDriftAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal drift of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousTemporalDriftAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousTemporalDriftAnalyzer(\n...     column=\"col\", dt_column=\"date\", period=\"M\"\n... )\n&gt;&gt;&gt; analyzer\nColumnContinuousTemporalDriftAnalyzer(\n  (column): col\n  (dt_column): date\n  (period): M\n  (nbins): None\n  (density): False\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(10),\n...         \"date\": pd.date_range(start=\"2017-01-01\", periods=10, freq=\"1D\"),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnDiscreteAnalyzer","title":"flamme.analyzer.ColumnDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a discrete distribution analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dropna</code> <code>bool</code> <p>If <code>True</code>, the NaN values are not included in the analysis.</p> <code>False</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnDiscreteAnalyzer(column=\"str\")\n&gt;&gt;&gt; analyzer\nColumnDiscreteAnalyzer(column=str, dropna=False, max_rows=20, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnSubsetAnalyzer","title":"flamme.analyzer.ColumnSubsetAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze only a subset of the columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>Soecifies the columns to select.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnSubsetAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnSubsetAnalyzer(columns=[\"float\", \"str\"], analyzer=NullValueAnalyzer())\n&gt;&gt;&gt; analyzer\nColumnSubsetAnalyzer(\n  (columns): 2 ['float', 'str']\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalContinuousAnalyzer","title":"flamme.analyzer.ColumnTemporalContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalContinuousAnalyzer(\n...     column=\"float\", dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalContinuousAnalyzer(column=float, dt_column=datetime, period=M, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalDiscreteAnalyzer","title":"flamme.analyzer.ColumnTemporalDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalDiscreteAnalyzer(\n...     column=\"str\", dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalDiscreteAnalyzer(column=str, dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalNullValueAnalyzer","title":"flamme.analyzer.ColumnTemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>A plot is generated for each column.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The list of columns to analyze. A plot is generated for each column. <code>None</code> means all the columns.</p> <code>None</code> <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalNullValueAnalyzer(\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nColumnTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ContentAnalyzer","title":"flamme.analyzer.ContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ContentAnalyzer\n&gt;&gt;&gt; analyzer = ContentAnalyzer(content=\"meow\")\n&gt;&gt;&gt; analyzer\nContentAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataFrameSummaryAnalyzer","title":"flamme.analyzer.DataFrameSummaryAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show a summary of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <code>sort</code> <code>bool</code> <p>If <code>True</code>, sort the columns by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import DataFrameSummaryAnalyzer\n&gt;&gt;&gt; analyzer = DataFrameSummaryAnalyzer()\n&gt;&gt;&gt; analyzer\nDataFrameSummaryAnalyzer(top=5, sort=False)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col1\": np.array([0, 1, 0, 1]),\n...         \"col2\": np.array([1, 0, 1, 0]),\n...         \"col3\": np.array([1, 1, 1, 1]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataTypeAnalyzer","title":"flamme.analyzer.DataTypeAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to find all the value types in each column.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import DataTypeAnalyzer\n&gt;&gt;&gt; analyzer = DataTypeAnalyzer()\n&gt;&gt;&gt; analyzer\nDataTypeAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, float(\"nan\"), 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"int\": pl.Int64, \"float\": pl.Float64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'int': Int64, 'float': Float64, 'str': String}\n  (types): {'int': {&lt;class 'int'&gt;, &lt;class 'NoneType'&gt;}, 'float': {&lt;class 'float'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DuplicatedRowAnalyzer","title":"flamme.analyzer.DuplicatedRowAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = DuplicatedRowAnalyzer()\n&gt;&gt;&gt; analyzer\nDuplicatedRowAnalyzer(columns=None, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.2, 4.2, 4.2, 2.2],\n...         \"col2\": [1, 1, 1, 1],\n...         \"col3\": [1, 2, 2, 2],\n...     },\n...     schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.FilteredAnalyzer","title":"flamme.analyzer.FilteredAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that filters the data before to analyze the data.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Soecifies the query.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import FilteredAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; analyzer = FilteredAnalyzer(query=\"float &gt;= 2.0\", analyzer=NullValueAnalyzer())\n&gt;&gt;&gt; analyzer\nFilteredAnalyzer(\n  (query): float &gt;= 2.0\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer","title":"flamme.analyzer.MappingAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that combine multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import (\n...     FilteredAnalyzer,\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n...     MappingAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = MappingAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()}\n... )\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer.add_analyzer","title":"flamme.analyzer.MappingAnalyzer.add_analyzer","text":"<pre><code>add_analyzer(\n    key: str,\n    analyzer: BaseAnalyzer,\n    replace_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an analyzer to the current analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the analyzer.</p> required <code>analyzer</code> <code>BaseAnalyzer</code> <p>The analyzer to add.</p> required <code>replace_ok</code> <code>bool</code> <p>If <code>False</code>, <code>KeyError</code> is raised if an analyzer with the same key exists. If <code>True</code>, the new analyzer will replace the existing analyzer.</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if an  analyzer with the same key exists.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import MappingAnalyzer, NullValueAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = MappingAnalyzer({\"null\": NullValueAnalyzer()})\n&gt;&gt;&gt; analyzer.add_analyzer(\"duplicate\", DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MarkdownAnalyzer","title":"flamme.analyzer.MarkdownAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that adds a mardown string to the report.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown description.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import MarkdownAnalyzer\n&gt;&gt;&gt; analyzer = MarkdownAnalyzer(desc=\"hello cats!\")\n&gt;&gt;&gt; analyzer\nMarkdownAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame({})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MostFrequentValuesAnalyzer","title":"flamme.analyzer.MostFrequentValuesAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a most frequent values analyzer for a given column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>drop_nulls</code> <code>bool</code> <p>If <code>True</code>, the null values are not included in the analysis.</p> <code>False</code> <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import MostFrequentValuesAnalyzer\n&gt;&gt;&gt; analyzer = MostFrequentValuesAnalyzer(column=\"col\")\n&gt;&gt;&gt; analyzer\nMostFrequentValuesAnalyzer(column=col, drop_nulls=False, top=100)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [None, 1, 0, 1]}, schema={\"col\": pl.Int64})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({1: 2, None: 1, 0: 1})\n  (column): col\n  (top): 100\n  (total): 4\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.NullValueAnalyzer","title":"flamme.analyzer.NullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a null value analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TableOfContentAnalyzer","title":"flamme.analyzer.TableOfContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a wrapper around an analyzer to add a table of content to the generated section report.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TableOfContentAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = TableOfContentAnalyzer(DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nTableOfContentAnalyzer(\n  (analyzer): DuplicatedRowAnalyzer(columns=None, figsize=None)\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.2, 4.2, 4.2, 2.2],\n...         \"col2\": [1, 1, 1, 1],\n...         \"col3\": [1, 2, 2, 2],\n...     },\n...     schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalNullValueAnalyzer","title":"flamme.analyzer.TemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = TemporalNullValueAnalyzer(dt_column=\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": [None, 1, 0, 1],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\"col\": pl.Int64, \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalRowCountAnalyzer","title":"flamme.analyzer.TemporalRowCountAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TemporalRowCountAnalyzer\n&gt;&gt;&gt; analyzer = TemporalRowCountAnalyzer(dt_column=\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nTemporalRowCountAnalyzer(dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.is_analyzer_config","title":"flamme.analyzer.is_analyzer_config","text":"<pre><code>is_analyzer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseAnalyzer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseAnalyzer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import is_analyzer_config\n&gt;&gt;&gt; is_analyzer_config({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\nTrue\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.setup_analyzer","title":"flamme.analyzer.setup_analyzer","text":"<pre><code>setup_analyzer(\n    analyzer: BaseAnalyzer | dict,\n) -&gt; BaseAnalyzer\n</code></pre> <p>Set up an analyzer.</p> <p>The analyzer is instantiated from its configuration by using the <code>BaseAnalyzer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>Specifies an analyzer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseAnalyzer</code> <p>An instantiated analyzer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import setup_analyzer\n&gt;&gt;&gt; analyzer = setup_analyzer({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n</code></pre>"},{"location":"refs/plot/","title":"plot","text":""},{"location":"refs/plot/#flamme.plot","title":"flamme.plot","text":"<p>Contain plotting functionalities.</p>"},{"location":"refs/plot/#flamme.plot.hist_continuous","title":"flamme.plot.hist_continuous","text":"<pre><code>hist_continuous(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    cdf: bool = True,\n    quantile: bool = True,\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>cdf</code> <code>bool</code> <p>If <code>True</code>, the CDF is added to the plot.</p> <code>True</code> <code>quantile</code> <code>bool</code> <p>If <code>True</code>, the 5% and 95% quantiles are added to the plot.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import hist_continuous\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.hist_continuous2","title":"flamme.plot.hist_continuous2","text":"<pre><code>hist_continuous2(\n    ax: Axes,\n    array1: ndarray,\n    array2: ndarray,\n    label1: str = \"first\",\n    label2: str = \"second\",\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the histogram of two arrays to compare the distributions.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array1</code> <code>ndarray</code> <p>The first array with the data.</p> required <code>array2</code> <code>ndarray</code> <p>The second array with the data.</p> required <code>label1</code> <code>str</code> <p>The label associated to the first array.</p> <code>'first'</code> <code>label2</code> <code>str</code> <p>The label associated to the second array.</p> <code>'second'</code> <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import hist_continuous2\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous2(ax, array1=np.arange(101), array2=np.arange(51))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.plot_cdf","title":"flamme.plot.plot_cdf","text":"<pre><code>plot_cdf(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    xmin: float = float(\"-inf\"),\n    xmax: float = float(\"inf\"),\n    color: str = \"tab:blue\",\n    labelcolor: str = \"black\",\n) -&gt; None\n</code></pre> <p>Plot the cumulative distribution function (CDF).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot the CDF.</p> <code>None</code> <code>xmin</code> <code>float</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('-inf')</code> <code>xmax</code> <code>float</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('inf')</code> <code>color</code> <code>str</code> <p>The plot color.</p> <code>'tab:blue'</code> <code>labelcolor</code> <code>str</code> <p>The label color.</p> <code>'black'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import plot_cdf\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_cdf(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.plot_null_temporal","title":"flamme.plot.plot_null_temporal","text":"<pre><code>plot_null_temporal(\n    ax: Axes,\n    nulls: Sequence,\n    totals: Sequence,\n    labels: Sequence,\n) -&gt; None\n</code></pre> <p>Plot the temporal distribution of the number of missing values.</p> <p><code>nulls</code>, <code>totals</code>, and <code>labels</code> must have the same length and have the same order.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>nulls</code> <code>Sequence</code> <p>The number of null values for each temporal period.</p> required <code>totals</code> <code>Sequence</code> <p>The number of total values for each temporal period.</p> required <code>labels</code> <code>Sequence</code> <p>The labels for each temporal period.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>nulls</code>, <code>totals</code>, and <code>labels</code> have different lengths.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import plot_null_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_null_temporal(\n...     ax, nulls=[1, 2, 3, 4], totals=[10, 12, 14, 16], labels=[\"jan\", \"feb\", \"mar\", \"apr\"]\n... )\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils","title":"flamme.plot.utils","text":"<p>Contain utility functions to generate plots.</p>"},{"location":"refs/plot/#flamme.plot.utils.auto_yscale_continuous","title":"flamme.plot.utils.auto_yscale_continuous","text":"<pre><code>auto_yscale_continuous(\n    array: ndarray, nbins: int | None = None\n) -&gt; str\n</code></pre> <p>Find a good scale for y-axis based on the data distribution.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The data to use to find the scale.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The scale for y-axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.plot.utils import auto_yscale_continuous\n&gt;&gt;&gt; auto_yscale_continuous(np.arange(100))\nlinear\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.axvline_median","title":"flamme.plot.utils.axvline_median","text":"<pre><code>axvline_median(\n    ax: Axes,\n    median: float,\n    label: str = \"median\",\n    color: str = \"black\",\n    linestyle: str = \"dashed\",\n    horizontalalignment: str = \"center\",\n) -&gt; None\n</code></pre> <p>Add a vertical line to represent the median value.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>median</code> <code>float</code> <p>The median value.</p> required <code>label</code> <code>str</code> <p>The associated label to show on the plot.</p> <code>'median'</code> <code>color</code> <code>str</code> <p>The line color.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The line style.</p> <code>'dashed'</code> <code>horizontalalignment</code> <code>str</code> <p>The horizontal alignment relative to the anchor point.</p> <code>'center'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import axvline_median\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; axvline_median(ax, median=42.0)\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.axvline_quantile","title":"flamme.plot.utils.axvline_quantile","text":"<pre><code>axvline_quantile(\n    ax: Axes,\n    quantile: float,\n    label: str,\n    color: str = \"black\",\n    linestyle: str = \"dashed\",\n    horizontalalignment: str = \"center\",\n) -&gt; None\n</code></pre> <p>Add a vertical line to represent a quantile value.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>quantile</code> <code>float</code> <p>The quantile value.</p> required <code>label</code> <code>str</code> <p>The associated label to show on the plot.</p> required <code>color</code> <code>str</code> <p>The line color.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The line style.</p> <code>'dashed'</code> <code>horizontalalignment</code> <code>str</code> <p>The horizontal alignment relative to the anchor point.</p> <code>'center'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import axvline_quantile\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; axvline_quantile(ax, quantile=42.0, label=\" q0.9\")\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.readable_xticklabels","title":"flamme.plot.utils.readable_xticklabels","text":"<pre><code>readable_xticklabels(\n    ax: Axes,\n    max_num_xticks: int = 100,\n    xticklabel_max_len: int = 20,\n    xticklabel_min: int = 10,\n) -&gt; None\n</code></pre> <p>Update the tick labels to make them easier to read, in particular if the tick labels are dense.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The figure axes to update.</p> required <code>max_num_xticks</code> <code>int</code> <p>The maximum number of ticks to show in the figure.</p> <code>100</code> <code>xticklabel_max_len</code> <code>int</code> <p>If a tick label has a length greater than this value, the tick labels are rotated vertically.</p> <code>20</code> <code>xticklabel_min</code> <code>int</code> <p>If the number of ticks is lower than this number the tick labels are rotated vertically.</p> <code>10</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import readable_xticklabels\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.hist(np.arange(10), bins=10)\n&gt;&gt;&gt; readable_xticklabels(ax)\n</code></pre>"},{"location":"refs/reporter/","title":"reporter","text":""},{"location":"refs/reporter/#flamme.reporter","title":"flamme.reporter","text":"<p>Contain reporters.</p>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter","title":"flamme.reporter.BaseReporter","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to compute a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): ParquetIngestor(path=/path/to/data.parquet)\n  (transformer): SequentialTransformer()\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter.compute","title":"flamme.reporter.BaseReporter.compute","text":"<pre><code>compute() -&gt; None\n</code></pre> <p>Generate a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(figsize=None),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.NoRepeatReporter","title":"flamme.reporter.NoRepeatReporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a reporter that computes the report only once.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>The reporter or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter, NoRepeatReporter\n&gt;&gt;&gt; reporter = NoRepeatReporter(\n...     reporter=Reporter(\n...         ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...         transformer=SequentialTransformer(transformers=[]),\n...         analyzer=NullValueAnalyzer(),\n...         report_path=\"/path/to/report.html\",\n...     ),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.Reporter","title":"flamme.reporter.Reporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a simple reporter.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The ingestor or its configuration.</p> required <code>transformer</code> <code>BaseTransformer | dict</code> <p>Specifies a <code>pandas.DataFrame</code> transformer or its configuration.</p> required <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The analyzer or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>6</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.is_reporter_config","title":"flamme.reporter.is_reporter_config","text":"<pre><code>is_reporter_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseReporter</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseReporter</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import is_reporter_config\n&gt;&gt;&gt; is_reporter_config(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"grizz.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\"_target_\": \"grizz.transformer.DropDuplicate\"},\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.setup_reporter","title":"flamme.reporter.setup_reporter","text":"<pre><code>setup_reporter(\n    reporter: BaseReporter | dict,\n) -&gt; BaseReporter\n</code></pre> <p>Set up a reporter.</p> <p>The reporter is instantiated from its configuration by using the <code>BaseReporter</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>Specifies an reporter or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseReporter</code> <p>An instantiated reporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import setup_reporter\n&gt;&gt;&gt; reporter = setup_reporter(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"grizz.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\"_target_\": \"grizz.transformer.DropDuplicate\"},\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): CsvIngestor(path=/path/to/data.csv)\n  (transformer): DropDuplicateTransformer(columns=None, ignore_missing=False)\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n</code></pre>"},{"location":"refs/schema/","title":"schema","text":""},{"location":"refs/schema/#flamme.schema","title":"flamme.schema","text":"<p>Contain functionalities to manipulate DataFrame's schemas.</p>"},{"location":"refs/schema/#flamme.schema.reader","title":"flamme.schema.reader","text":"<p>Contain schema readers.</p>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader","title":"flamme.schema.reader.BaseSchemaReader","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(\n...         path, index=False\n...     )\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader.read","title":"flamme.schema.reader.BaseSchemaReader.read","text":"<pre><code>read() -&gt; Schema\n</code></pre> <p>Read the schema associated to a DataFrame.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>The ingested DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(\n...         path, index=False\n...     )\n...     reader = ParquetSchemaReader(path)\n...     schema = reader.read()\n...     schema\n...\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ClickHouseSchemaReader","title":"flamme.schema.reader.ClickHouseSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The clickhouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.schema.reader import ClickHouseSchemaReader\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; reader = ClickHouseSchemaReader(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; schema = reader.read()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ParquetSchemaReader","title":"flamme.schema.reader.ParquetSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a parquet schema reader.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(\n...         path, index=False\n...     )\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.SchemaReader","title":"flamme.schema.reader.SchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.schema.reader import SchemaReader\n&gt;&gt;&gt; reader = SchemaReader(\n...     frame=pd.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [1.1, 2.2, 3.3, 4.4, 5.5],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; reader\nSchemaReader(shape=(5, 3))\n&gt;&gt;&gt; schema = reader.read()\n&gt;&gt;&gt; schema\ncol1: int64\ncol2: double\ncol4: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.is_schema_reader_config","title":"flamme.schema.reader.is_schema_reader_config","text":"<pre><code>is_schema_reader_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseSchemaReader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseSchemaReader</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import is_schema_reader_config\n&gt;&gt;&gt; is_schema_reader_config(\n...     {\n...         \"_target_\": \"flamme.schema.reader.ParquetSchemaReader\",\n...         \"path\": \"/path/to/data.parquet\",\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.setup_schema_reader","title":"flamme.schema.reader.setup_schema_reader","text":"<pre><code>setup_schema_reader(\n    reader: BaseSchemaReader | dict,\n) -&gt; BaseSchemaReader\n</code></pre> <p>Set up a schema reader.</p> <p>The reader is instantiated from its configuration by using the <code>BaseSchemaReader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reader</code> <code>BaseSchemaReader | dict</code> <p>Specifies a schema reader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseSchemaReader</code> <p>An instantiated schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import setup_schema_reader\n&gt;&gt;&gt; reader = setup_schema_reader(\n...     {\n...         \"_target_\": \"flamme.schema.reader.ParquetSchemaReader\",\n...         \"path\": \"/path/to/data.parquet\",\n...     }\n... )\n&gt;&gt;&gt; reader\nParquetSchemaReader(path=.../data.parquet)\n</code></pre>"},{"location":"refs/section/","title":"section","text":""},{"location":"refs/section/#flamme.section","title":"flamme.section","text":"<p>Contain sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection","title":"flamme.section.BaseSection","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to manage sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection.get_statistics","title":"flamme.section.BaseSection.get_statistics  <code>abstractmethod</code>","text":"<pre><code>get_statistics() -&gt; dict\n</code></pre> <p>Return the statistics associated to the section.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The statistics.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_body","title":"flamme.section.BaseSection.render_html_body  <code>abstractmethod</code>","text":"<pre><code>render_html_body(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n) -&gt; str\n</code></pre> <p>Return the HTML body associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML body associated to the section.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_toc","title":"flamme.section.BaseSection.render_html_toc  <code>abstractmethod</code>","text":"<pre><code>render_html_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection","title":"flamme.section.ColumnContinuousAdvancedSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousAdvancedSection(\n...     series=pd.Series([np.nan, *list(range(101)), np.nan]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousAdvancedSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'num_nulls': 2, 'nunique': 102, 'mean': 50.0, 'std': 29.30...,\n 'skewness': 0.0, 'kurtosis': -1.200235294117647, 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1, 'num_non_nulls': 101}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection.figsize","title":"flamme.section.ColumnContinuousAdvancedSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection","title":"flamme.section.ColumnContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousSection(\n...     series=pd.Series([float(\"nan\"), *list(range(101)), float(\"nan\")]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'num_nulls': 2, 'nunique': 102, 'mean': 50.0, 'std': 29.30...,\n 'skewness': 0.0, 'kurtosis': -1.200235294117647, 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1, 'num_non_nulls': 101}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection.figsize","title":"flamme.section.ColumnContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousTemporalDriftSection","title":"flamme.section.ColumnContinuousTemporalDriftSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal drift of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousTemporalDriftSection\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = pd.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(10),\n...         \"date\": pd.date_range(start=\"2017-01-01\", periods=10, freq=\"1D\"),\n...     }\n... )\n&gt;&gt;&gt; section = ColumnContinuousTemporalDriftSection(\n...     frame=data, column=\"col\", dt_column=\"date\", period=\"M\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousTemporalDriftSection(\n  (column): col\n  (dt_column): date\n  (period): M\n  (nbins): None\n  (density): False\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousTemporalDriftSection.figsize","title":"flamme.section.ColumnContinuousTemporalDriftSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection","title":"flamme.section.ColumnDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a discrete distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>null_values</code> <code>int</code> <p>The number of null values.</p> <code>0</code> <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import ColumnDiscreteSection\n&gt;&gt;&gt; section = ColumnDiscreteSection(counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\")\n&gt;&gt;&gt; section\nColumnDiscreteSection(\n  (null_values): 0\n  (column): col\n  (yscale): auto\n  (max_rows): 20\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)], 'nunique': 3, 'total': 12}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection.figsize","title":"flamme.section.ColumnDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection","title":"flamme.section.ColumnTemporalContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnTemporalContinuousSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col\": np.array([1.2, 4.2, np.nan, 2.2]),\n...             \"datetime\": pd.to_datetime(\n...                 [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...             ),\n...         }\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalContinuousSection(\n  (column): col\n  (dt_column): datetime\n  (period): M\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection.figsize","title":"flamme.section.ColumnTemporalContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection","title":"flamme.section.ColumnTemporalDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column of the DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import ColumnTemporalDiscreteSection\n&gt;&gt;&gt; section = ColumnTemporalDiscreteSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col\": np.array([1, 42, np.nan, 22]),\n...             \"col2\": [\"a\", \"b\", 1, \"a\"],\n...             \"datetime\": pd.to_datetime(\n...                 [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...             ),\n...         }\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection.figsize","title":"flamme.section.ColumnTemporalDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection","title":"flamme.section.ColumnTemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalNullValueSection\n&gt;&gt;&gt; dataframe = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = ColumnTemporalNullValueSection(\n...     frame=dataframe, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; section\nColumnTemporalNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.columns","title":"flamme.section.ColumnTemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.dt_column","title":"flamme.section.ColumnTemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.figsize","title":"flamme.section.ColumnTemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.frame","title":"flamme.section.ColumnTemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.ncols","title":"flamme.section.ColumnTemporalNullValueSection.ncols  <code>property</code>","text":"<pre><code>ncols: int\n</code></pre> <p>The number of columns to show the figures.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.period","title":"flamme.section.ColumnTemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.ContentSection","title":"flamme.section.ContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import ContentSection\n&gt;&gt;&gt; section = ContentSection(content=\"meow\")\n&gt;&gt;&gt; section\nContentSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.DataFrameSummarySection","title":"flamme.section.DataFrameSummarySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that returns a summary of a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <p>Example usage:</p> <p>```pycon</p> <p>import pandas as pd import numpy as np from flamme.section import DataFrameSummarySection section = DataFrameSummarySection( ...     frame=pd.DataFrame( ...         { ...             \"col1\": np.array([1.2, 4.2, 4.2, 2.2]), ...             \"col2\": np.array([1, 1, 1, 1]), ...             \"col3\": np.array([1, 2, 2, 2]), ...         } ...     ) ... ) section DataFrameSummarySection(top=5) section.get_statistics() {'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 0, 0), 'nunique': (3, 1, 2), 'column_types': ({}, {}, {})}"},{"location":"refs/section/#flamme.section.DataFrameSummarySection.frame","title":"flamme.section.DataFrameSummarySection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.DataTypeSection","title":"flamme.section.DataTypeSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the data type of each column.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>dict[str, DataType]</code> <p>The data type for each column.</p> required <code>types</code> <code>dict[str, set]</code> <p>The types of the values in each column. A column can contain multiple types. The keys are the column names.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import DataTypeSection\n&gt;&gt;&gt; section = DataTypeSection(\n...     dtypes={\n...         \"float\": pl.Float64(),\n...         \"int\": pl.Int64(),\n...         \"str\": pl.String(),\n...     },\n...     types={\"float\": {float}, \"int\": {int}, \"str\": {str, type(None)}},\n... )\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'float': Float64, 'int': Int64, 'str': String}\n  (types): {'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {...}}\n)\n&gt;&gt;&gt; section.get_statistics()\n{'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection","title":"flamme.section.DuplicatedRowSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import DuplicatedRowSection\n&gt;&gt;&gt; section = DuplicatedRowSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1.2, 4.2, 4.2, 2.2],\n...             \"col2\": [1, 1, 1, 1],\n...             \"col3\": [1, 2, 2, 2],\n...         },\n...         schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...     )\n... )\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.columns","title":"flamme.section.DuplicatedRowSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...] | None\n</code></pre> <p>Tuple or <code>None</code>: The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.figsize","title":"flamme.section.DuplicatedRowSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.frame","title":"flamme.section.DuplicatedRowSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.EmptySection","title":"flamme.section.EmptySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement an empty section.</p> <p>This section is implemented to deal with missing columns or to skip some analyses.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import EmptySection\n&gt;&gt;&gt; section = EmptySection()\n&gt;&gt;&gt; section\nEmptySection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MarkdownSection","title":"flamme.section.MarkdownSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that converts a markdown string into HTML.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown string to convert.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import MarkdownSection\n&gt;&gt;&gt; section = MarkdownSection(desc=\"meow\")\n&gt;&gt;&gt; section\nMarkdownSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MostFrequentValuesSection","title":"flamme.section.MostFrequentValuesSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the most frequent values for a given columns.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of occurrences for all values.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import MostFrequentValuesSection\n&gt;&gt;&gt; section = MostFrequentValuesSection(\n...     counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\"\n... )\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({'c': 6, 'a': 4, 'b': 2})\n  (column): col\n  (top): 100\n  (total): 12\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)]}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection","title":"flamme.section.NullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the number of null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>ndarray</code> <p>The number of null values for each column.</p> required <code>total_count</code> <code>ndarray</code> <p>The total number of values for each column.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import NullValueSection\n&gt;&gt;&gt; section = NullValueSection(\n...     columns=[\"col1\", \"col2\", \"col3\"],\n...     null_count=np.array([0, 1, 2]),\n...     total_count=np.array([5, 5, 5]),\n... )\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('col1', 'col2', 'col3')\n  (null_count): array([0, 1, 2])\n  (total_count): array([5, 5, 5])\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 1, 2), 'total_count': (5, 5, 5)}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection.columns","title":"flamme.section.NullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.figsize","title":"flamme.section.NullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.null_count","title":"flamme.section.NullValueSection.null_count  <code>property</code>","text":"<pre><code>null_count: ndarray\n</code></pre> <p>The number of null values for each column.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.total_count","title":"flamme.section.NullValueSection.total_count  <code>property</code>","text":"<pre><code>total_count: ndarray\n</code></pre> <p>The total number of values for each column.</p>"},{"location":"refs/section/#flamme.section.SectionDict","title":"flamme.section.SectionDict","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to manage a dictionary of sections.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>dict[str, BaseSection]</code> <p>The dictionary of sections.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import SectionDict, ContentSection, TemporalRowCountSection\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"datetime\": pd.to_datetime(\n...             [\n...                 \"2020-01-03\",\n...                 \"2020-01-04\",\n...                 \"2020-01-05\",\n...                 \"2020-02-03\",\n...                 \"2020-03-03\",\n...                 \"2020-04-03\",\n...             ]\n...         )\n...     }\n... )\n&gt;&gt;&gt; section = SectionDict(\n...     {\n...         \"content\": ContentSection(\"meow\"),\n...         \"rows\": TemporalRowCountSection(frame, dt_column=\"datetime\", period=\"M\"),\n...     }\n... )\n&gt;&gt;&gt; section\nSectionDict(\n  (content): ContentSection()\n  (rows): TemporalRowCountSection(dt_column=datetime, period=M, figsize=None)\n)\n&gt;&gt;&gt; section.get_statistics()\n{'content': {}, 'rows': {}}\n</code></pre>"},{"location":"refs/section/#flamme.section.TableOfContentSection","title":"flamme.section.TableOfContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a wrapper section that generates a table of content before the section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseSection</code> <p>The section.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import TableOfContentSection, DuplicatedRowSection\n&gt;&gt;&gt; section = TableOfContentSection(\n...     DuplicatedRowSection(\n...         frame=pl.DataFrame(\n...             {\n...                 \"col1\": [1.2, 4.2, 4.2, 2.2],\n...                 \"col2\": [1, 1, 1, 1],\n...                 \"col3\": [1, 2, 2, 2],\n...             },\n...             schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...         )\n...     )\n... )\n&gt;&gt;&gt; section\nTableOfContentSection(\n  (section): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection","title":"flamme.section.TemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import TemporalNullValueSection\n&gt;&gt;&gt; section = TemporalNullValueSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, 1.0, 0.0, 1.0],\n...             \"col2\": [None, 1, 0, None],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     columns=[\"col1\", \"col2\"],\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nTemporalNullValueSection(\n  (columns): ('col1', 'col2')\n  (dt_column): datetime\n  (period): 1mo\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.columns","title":"flamme.section.TemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.dt_column","title":"flamme.section.TemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.figsize","title":"flamme.section.TemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.frame","title":"flamme.section.TemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.period","title":"flamme.section.TemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection","title":"flamme.section.TemporalRowCountSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import TemporalRowCountSection\n&gt;&gt;&gt; section = TemporalRowCountSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"datetime\": pd.to_datetime(\n...                 [\n...                     \"2020-01-03\",\n...                     \"2020-01-04\",\n...                     \"2020-01-05\",\n...                     \"2020-02-03\",\n...                     \"2020-03-03\",\n...                     \"2020-04-03\",\n...                 ]\n...             )\n...         }\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nTemporalRowCountSection(dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.dt_column","title":"flamme.section.TemporalRowCountSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.figsize","title":"flamme.section.TemporalRowCountSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.frame","title":"flamme.section.TemporalRowCountSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.period","title":"flamme.section.TemporalRowCountSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#flamme.utils","title":"flamme.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#flamme.utils.setup_object","title":"flamme.utils.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.utils import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"}]}