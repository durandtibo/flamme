{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A library to generate custom reports of pandas DataFrames.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>flamme</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>flamme</code> to a new version will possibly break any code that was using the old version of <code>flamme</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>flamme</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install flamme\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>flamme</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'flamme[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>flamme</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/flamme.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate flamme\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>flamme</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/analyzer/","title":"analyzer","text":""},{"location":"refs/analyzer/#flamme.analyzer","title":"flamme.analyzer","text":"<p>Contain DataFrame analyzers.</p>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer","title":"flamme.analyzer.BaseAnalyzer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to analyze a DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer.analyze","title":"flamme.analyzer.BaseAnalyzer.analyze","text":"<pre><code>analyze(frame: DataFrame) -&gt; BaseSection\n</code></pre> <p>Analyze the data in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data to analyze.</p> required <p>Returns:</p> Type Description <code>BaseSection</code> <p>The section report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ChoiceAnalyzer","title":"flamme.analyzer.ChoiceAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>selection_fn</code> <code>Callable[[DataFrame], str]</code> <p>Specifies a callable with the selection logic. The callable returns the key of the analyzer to use based on the data in the input DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import (\n...     ChoiceAnalyzer,\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = ChoiceAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()},\n...     selection_fn=lambda frame: (\n...         \"null\" if frame.null_count().pipe(sum).item() &gt; 0 else \"duplicate\"\n...     ),\n... )\n&gt;&gt;&gt; analyzer\nChoiceAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, 1.2, 2.2],\n...         \"int\": [42, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", \"C\", \"D\"],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAdvancedAnalyzer","title":"flamme.analyzer.ColumnContinuousAdvancedAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAdvancedAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAdvancedAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAdvancedAnalyzer(column=float, nbins=None, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAnalyzer","title":"flamme.analyzer.ColumnContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q0'</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q1'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAnalyzer(column=float, nbins=None, yscale=auto, xmin=q0, xmax=q1, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousTemporalDriftAnalyzer","title":"flamme.analyzer.ColumnContinuousTemporalDriftAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal drift of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousTemporalDriftAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousTemporalDriftAnalyzer(\n...     column=\"col\", dt_column=\"date\", period=\"1mo\"\n... )\n&gt;&gt;&gt; analyzer\nColumnContinuousTemporalDriftAnalyzer(\n  (column): col\n  (dt_column): date\n  (period): 1mo\n  (nbins): None\n  (density): False\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(59),\n...         \"datetime\": pl.datetime_range(\n...             start=datetime(year=2018, month=1, day=1, tzinfo=timezone.utc),\n...             end=datetime(year=2018, month=3, day=1, tzinfo=timezone.utc),\n...             interval=\"1d\",\n...             closed=\"left\",\n...             eager=True,\n...         ),\n...     },\n...     schema={\"col\": pl.Int64, \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnDiscreteAnalyzer","title":"flamme.analyzer.ColumnDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a discrete distribution analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>drop_nulls</code> <code>bool</code> <p>If <code>True</code>, the NaN values are not included in the analysis.</p> <code>False</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnDiscreteAnalyzer(column=\"str\")\n&gt;&gt;&gt; analyzer\nColumnDiscreteAnalyzer(column=str, drop_nulls=False, max_rows=20, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nColumnDiscreteSection(\n  (null_values): 2\n  (column): str\n  (yscale): auto\n  (max_rows): 20\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnSubsetAnalyzer","title":"flamme.analyzer.ColumnSubsetAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze only a subset of the columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>Soecifies the columns to select.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnSubsetAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnSubsetAnalyzer(columns=[\"float\", \"str\"], analyzer=NullValueAnalyzer())\n&gt;&gt;&gt; analyzer\nColumnSubsetAnalyzer(\n  (columns): 2 ['float', 'str']\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'str')\n  (null_count): array([1, 2])\n  (total_count): array([4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalContinuousAnalyzer","title":"flamme.analyzer.ColumnTemporalContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalContinuousAnalyzer(\n...     column=\"col\", dt_column=\"datetime\", period=\"1mo\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalContinuousAnalyzer(column=col, dt_column=datetime, period=1mo, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"datetime\": [\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=1, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=2, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"col\": pl.Float64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nColumnTemporalContinuousSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (yscale): auto\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalDiscreteAnalyzer","title":"flamme.analyzer.ColumnTemporalDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalDiscreteAnalyzer(\n...     column=\"col\", dt_column=\"datetime\", period=\"1mo\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalDiscreteAnalyzer(column=col, dt_column=datetime, period=1mo, proportion=False, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": [1, 42, None, 42],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\"col\": pl.Int64, \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nColumnTemporalDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (proportion): False\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalDriftDiscreteAnalyzer","title":"flamme.analyzer.ColumnTemporalDriftDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalDriftDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalDriftDiscreteAnalyzer(\n...     column=\"col\", dt_column=\"datetime\", period=\"1mo\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalDriftDiscreteAnalyzer(column=col, dt_column=datetime, period=1mo, proportion=False, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": [1, 42, None, 42],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\"col\": pl.Int64, \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nColumnTemporalDriftDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (proportion): False\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalNullValueAnalyzer","title":"flamme.analyzer.ColumnTemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>A plot is generated for each column.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The list of columns to analyze. A plot is generated for each column. <code>None</code> means all the columns.</p> <code>None</code> <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalNullValueAnalyzer(\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nColumnTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nColumnTemporalNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ContentAnalyzer","title":"flamme.analyzer.ContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import ContentAnalyzer\n&gt;&gt;&gt; analyzer = ContentAnalyzer(content=\"meow\")\n&gt;&gt;&gt; analyzer\nContentAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nContentSection()\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataFrameSummaryAnalyzer","title":"flamme.analyzer.DataFrameSummaryAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show a summary of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <code>sort</code> <code>bool</code> <p>If <code>True</code>, sort the columns by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import DataFrameSummaryAnalyzer\n&gt;&gt;&gt; analyzer = DataFrameSummaryAnalyzer()\n&gt;&gt;&gt; analyzer\nDataFrameSummaryAnalyzer(top=5, sort=False)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 0, 1],\n...         \"col2\": [1, 0, 1, 0],\n...         \"col3\": [1, 1, 1, 1],\n...     },\n...     schema={\"col1\": pl.Int64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDataFrameSummarySection(top=5)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataTypeAnalyzer","title":"flamme.analyzer.DataTypeAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to find all the value types in each column.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import DataTypeAnalyzer\n&gt;&gt;&gt; analyzer = DataTypeAnalyzer()\n&gt;&gt;&gt; analyzer\nDataTypeAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [42, 1, 0, 1],\n...         \"float\": [1.2, 4.2, float(\"nan\"), 2.2],\n...         \"str\": [\"A\", \"B\", \"C\", \"D\"],\n...     },\n...     schema={\"int\": pl.Int64, \"float\": pl.Float64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'int': Int64, 'float': Float64, 'str': String}\n  (types): {'int': {&lt;class 'int'&gt;}, 'float': {&lt;class 'float'&gt;}, 'str': {&lt;class 'str'&gt;}}\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DuplicatedRowAnalyzer","title":"flamme.analyzer.DuplicatedRowAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = DuplicatedRowAnalyzer()\n&gt;&gt;&gt; analyzer\nDuplicatedRowAnalyzer(columns=None, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.2, 4.2, 4.2, 2.2],\n...         \"col2\": [1, 1, 1, 1],\n...         \"col3\": [1, 2, 2, 2],\n...     },\n...     schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer","title":"flamme.analyzer.MappingAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that combine multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import (\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n...     MappingAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = MappingAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()}\n... )\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nSectionDict(\n  (null): NullValueSection(\n      (columns): ('float', 'int', 'str')\n      (null_count): array([1, 1, 2])\n      (total_count): array([4, 4, 4])\n      (figsize): None\n    )\n  (duplicate): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer.add_analyzer","title":"flamme.analyzer.MappingAnalyzer.add_analyzer","text":"<pre><code>add_analyzer(\n    key: str,\n    analyzer: BaseAnalyzer,\n    replace_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an analyzer to the current analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the analyzer.</p> required <code>analyzer</code> <code>BaseAnalyzer</code> <p>The analyzer to add.</p> required <code>replace_ok</code> <code>bool</code> <p>If <code>False</code>, <code>KeyError</code> is raised if an analyzer with the same key exists. If <code>True</code>, the new analyzer will replace the existing analyzer.</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if an  analyzer with the same key exists.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import MappingAnalyzer, NullValueAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = MappingAnalyzer({\"null\": NullValueAnalyzer()})\n&gt;&gt;&gt; analyzer.add_analyzer(\"duplicate\", DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nSectionDict(\n  (null): NullValueSection(\n      (columns): ('float', 'int', 'str')\n      (null_count): array([1, 1, 2])\n      (total_count): array([4, 4, 4])\n      (figsize): None\n    )\n  (duplicate): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MarkdownAnalyzer","title":"flamme.analyzer.MarkdownAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that adds a mardown string to the report.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown description.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import MarkdownAnalyzer\n&gt;&gt;&gt; analyzer = MarkdownAnalyzer(desc=\"hello cats!\")\n&gt;&gt;&gt; analyzer\nMarkdownAnalyzer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nMarkdownSection()\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MostFrequentValuesAnalyzer","title":"flamme.analyzer.MostFrequentValuesAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a most frequent values analyzer for a given column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>drop_nulls</code> <code>bool</code> <p>If <code>True</code>, the null values are not included in the analysis.</p> <code>False</code> <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import MostFrequentValuesAnalyzer\n&gt;&gt;&gt; analyzer = MostFrequentValuesAnalyzer(column=\"col\")\n&gt;&gt;&gt; analyzer\nMostFrequentValuesAnalyzer(column=col, drop_nulls=False, top=100)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [None, 1, 0, 1]}, schema={\"col\": pl.Int64})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({1: 2, None: 1, 0: 1})\n  (column): col\n  (top): 100\n  (total): 4\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.NullValueAnalyzer","title":"flamme.analyzer.NullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a null value analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([1, 1, 2])\n  (total_count): array([4, 4, 4])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TableOfContentAnalyzer","title":"flamme.analyzer.TableOfContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a wrapper around an analyzer to add a table of content to the generated section report.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TableOfContentAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = TableOfContentAnalyzer(DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nTableOfContentAnalyzer(\n  (analyzer): DuplicatedRowAnalyzer(columns=None, figsize=None)\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.2, 4.2, 4.2, 2.2],\n...         \"col2\": [1, 1, 1, 1],\n...         \"col3\": [1, 2, 2, 2],\n...     },\n...     schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nTableOfContentSection(\n  (section): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n  (max_toc_depth): 1\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalNullValueAnalyzer","title":"flamme.analyzer.TemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = TemporalNullValueAnalyzer(dt_column=\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col\": [None, 1, 0, 1],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\"col\": pl.Int64, \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nTemporalNullValueSection(\n  (columns): ('col',)\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalRowCountAnalyzer","title":"flamme.analyzer.TemporalRowCountAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TemporalRowCountAnalyzer\n&gt;&gt;&gt; analyzer = TemporalRowCountAnalyzer(dt_column=\"datetime\", period=\"1mo\")\n&gt;&gt;&gt; analyzer\nTemporalRowCountAnalyzer(dt_column=datetime, period=1mo, figsize=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nTemporalRowCountSection(dt_column=datetime, period=1mo, figsize=None)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TransformAnalyzer","title":"flamme.analyzer.TransformAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that filters the data before to analyze the data.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>Soecifies the transformer.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.analyzer import TransformAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; from grizz.transformer import SqlTransformer\n&gt;&gt;&gt; analyzer = TransformAnalyzer(\n...     transformer=SqlTransformer(\"SELECT * FROM self WHERE float &gt; 1\"),\n...     analyzer=NullValueAnalyzer(),\n... )\n&gt;&gt;&gt; analyzer\nTransformAnalyzer(\n  (transformer): SqlTransformer(\n      (query): SELECT * FROM self WHERE float &gt; 1\n    )\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"int\": [None, 1, 0, 1],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"float\": pl.Float64, \"int\": pl.Int64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (null_count): array([0, 1, 1])\n  (total_count): array([3, 3, 3])\n  (figsize): None\n)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.is_analyzer_config","title":"flamme.analyzer.is_analyzer_config","text":"<pre><code>is_analyzer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseAnalyzer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseAnalyzer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import is_analyzer_config\n&gt;&gt;&gt; is_analyzer_config({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\nTrue\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.setup_analyzer","title":"flamme.analyzer.setup_analyzer","text":"<pre><code>setup_analyzer(\n    analyzer: BaseAnalyzer | dict,\n) -&gt; BaseAnalyzer\n</code></pre> <p>Set up an analyzer.</p> <p>The analyzer is instantiated from its configuration by using the <code>BaseAnalyzer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>Specifies an analyzer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseAnalyzer</code> <p>An instantiated analyzer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import setup_analyzer\n&gt;&gt;&gt; analyzer = setup_analyzer({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n</code></pre>"},{"location":"refs/plot/","title":"plot","text":""},{"location":"refs/plot/#flamme.plot","title":"flamme.plot","text":"<p>Contain plotting functionalities.</p>"},{"location":"refs/plot/#flamme.plot.bar_discrete","title":"flamme.plot.bar_discrete","text":"<pre><code>bar_discrete(\n    ax: Axes,\n    names: Sequence,\n    counts: Sequence[int],\n    yscale: str = \"auto\",\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>names</code> <code>Sequence</code> <p>The name of the values to plot.</p> required <code>counts</code> <code>Sequence[int]</code> <p>The number of value occurrences.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import bar_discrete\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; bar_discrete(ax, names=[\"a\", \"b\", \"c\", \"d\"], counts=[5, 100, 42, 27])\n</code></pre>"},{"location":"refs/plot/#flamme.plot.bar_discrete_temporal","title":"flamme.plot.bar_discrete_temporal","text":"<pre><code>bar_discrete_temporal(\n    ax: Axes,\n    counts: ndarray,\n    steps: Sequence | None = None,\n    values: Sequence | None = None,\n    proportion: bool = False,\n) -&gt; None\n</code></pre> <p>Plot the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>counts</code> <code>ndarray</code> <p>A 2-d array that indicates the number of occurrences for each value and time step. The first dimension represents the value and the second dimension represents the steps.</p> required <code>steps</code> <code>Sequence | None</code> <p>The name associated to each step.</p> <code>None</code> <code>values</code> <code>Sequence | None</code> <p>The name associated to each value.</p> <code>None</code> <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import bar_discrete_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; bar_discrete_temporal(\n...     ax, counts=np.ones((5, 20)), values=list(range(5)), steps=list(range(20))\n... )\n</code></pre>"},{"location":"refs/plot/#flamme.plot.boxplot_continuous","title":"flamme.plot.boxplot_continuous","text":"<pre><code>boxplot_continuous(\n    ax: Axes,\n    array: ndarray,\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import boxplot_continuous\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; boxplot_continuous(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.boxplot_continuous_temporal","title":"flamme.plot.boxplot_continuous_temporal","text":"<pre><code>boxplot_continuous_temporal(\n    ax: Axes,\n    data: Sequence[ndarray],\n    steps: Sequence,\n    ymin: float | str | None = None,\n    ymax: float | str | None = None,\n    yscale: str = \"linear\",\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>data</code> <code>Sequence[ndarray]</code> <p>The sequence of data where each item is a 1-d array with the values of the time step.</p> required <code>steps</code> <code>Sequence</code> <p>The sequence time step names.</p> required <code>ymin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>ymax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>data</code> and <code>steps</code> have different lengths</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import boxplot_continuous_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = [rng.standard_normal(1000) for _ in range(10)]\n&gt;&gt;&gt; boxplot_continuous_temporal(ax, data=data, steps=list(range(len(data))))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.hist_continuous","title":"flamme.plot.hist_continuous","text":"<pre><code>hist_continuous(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    cdf: bool = True,\n    quantile: bool = True,\n) -&gt; None\n</code></pre> <p>Plot the histogram of an array containing continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>cdf</code> <code>bool</code> <p>If <code>True</code>, the CDF is added to the plot.</p> <code>True</code> <code>quantile</code> <code>bool</code> <p>If <code>True</code>, the 5% and 95% quantiles are added to the plot.</p> <code>True</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import hist_continuous\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.hist_continuous2","title":"flamme.plot.hist_continuous2","text":"<pre><code>hist_continuous2(\n    ax: Axes,\n    array1: ndarray,\n    array2: ndarray,\n    label1: str = \"first\",\n    label2: str = \"second\",\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n) -&gt; None\n</code></pre> <p>Plot the histogram of two arrays to compare the distributions.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array1</code> <code>ndarray</code> <p>The first array with the data.</p> required <code>array2</code> <code>ndarray</code> <p>The second array with the data.</p> required <code>label1</code> <code>str</code> <p>The label associated to the first array.</p> <code>'first'</code> <code>label2</code> <code>str</code> <p>The label associated to the second array.</p> <code>'second'</code> <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import hist_continuous2\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; hist_continuous2(ax, array1=np.arange(101), array2=np.arange(51))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.plot_cdf","title":"flamme.plot.plot_cdf","text":"<pre><code>plot_cdf(\n    ax: Axes,\n    array: ndarray,\n    nbins: int | None = None,\n    xmin: float = float(\"-inf\"),\n    xmax: float = float(\"inf\"),\n    color: str = \"tab:blue\",\n    labelcolor: str = \"black\",\n) -&gt; None\n</code></pre> <p>Plot the cumulative distribution function (CDF).</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes of the matplotlib figure to update.</p> required <code>array</code> <code>ndarray</code> <p>The array with the data.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins to use to plot the CDF.</p> <code>None</code> <code>xmin</code> <code>float</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('-inf')</code> <code>xmax</code> <code>float</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>float('inf')</code> <code>color</code> <code>str</code> <p>The plot color.</p> <code>'tab:blue'</code> <code>labelcolor</code> <code>str</code> <p>The label color.</p> <code>'black'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import plot_cdf\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_cdf(ax, array=np.arange(101))\n</code></pre>"},{"location":"refs/plot/#flamme.plot.plot_null_temporal","title":"flamme.plot.plot_null_temporal","text":"<pre><code>plot_null_temporal(\n    ax: Axes,\n    nulls: Sequence,\n    totals: Sequence,\n    labels: Sequence,\n) -&gt; None\n</code></pre> <p>Plot the temporal distribution of the number of missing values.</p> <p><code>nulls</code>, <code>totals</code>, and <code>labels</code> must have the same length and have the same order.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>nulls</code> <code>Sequence</code> <p>The number of null values for each temporal period.</p> required <code>totals</code> <code>Sequence</code> <p>The number of total values for each temporal period.</p> required <code>labels</code> <code>Sequence</code> <p>The labels for each temporal period.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if <code>nulls</code>, <code>totals</code>, and <code>labels</code> have different lengths.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot import plot_null_temporal\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; plot_null_temporal(\n...     ax, nulls=[1, 2, 3, 4], totals=[10, 12, 14, 16], labels=[\"jan\", \"feb\", \"mar\", \"apr\"]\n... )\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils","title":"flamme.plot.utils","text":"<p>Contain utility functions to generate plots.</p>"},{"location":"refs/plot/#flamme.plot.utils.auto_yscale_continuous","title":"flamme.plot.utils.auto_yscale_continuous","text":"<pre><code>auto_yscale_continuous(\n    array: ndarray, nbins: int | None = None\n) -&gt; str\n</code></pre> <p>Find a good scale for y-axis based on the data distribution.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The data to use to find the scale.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The scale for y-axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.plot.utils import auto_yscale_continuous\n&gt;&gt;&gt; auto_yscale_continuous(np.arange(100))\nlinear\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.auto_yscale_discrete","title":"flamme.plot.utils.auto_yscale_discrete","text":"<pre><code>auto_yscale_discrete(\n    min_count: int, max_count: int, threshold: int = 50\n) -&gt; str\n</code></pre> <p>Find a good scale for y-axis based on the data distribution.</p> <p>Parameters:</p> Name Type Description Default <code>min_count</code> <code>int</code> <p>The minimal count value.</p> required <code>max_count</code> <code>int</code> <p>The maximal count value.</p> required <code>threshold</code> <code>int</code> <p>The threshold used to control the transition from linear to log scale. <code>50</code> means the ratio <code>max_count/min_count</code> must be greater than 50 to use the log scale. If it is lower than 50, the linear scale is used.</p> <code>50</code> <p>Returns:</p> Type Description <code>str</code> <p>The scale for y-axis.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.plot.utils import auto_yscale_discrete\n&gt;&gt;&gt; auto_yscale_discrete(min_count=5, max_count=10)\nlinear\n&gt;&gt;&gt; auto_yscale_discrete(min_count=5, max_count=1000)\nlog\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.axvline_median","title":"flamme.plot.utils.axvline_median","text":"<pre><code>axvline_median(\n    ax: Axes,\n    median: float,\n    label: str = \"median\",\n    color: str = \"black\",\n    linestyle: str = \"dashed\",\n    horizontalalignment: str = \"center\",\n) -&gt; None\n</code></pre> <p>Add a vertical line to represent the median value.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>median</code> <code>float</code> <p>The median value.</p> required <code>label</code> <code>str</code> <p>The associated label to show on the plot.</p> <code>'median'</code> <code>color</code> <code>str</code> <p>The line color.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The line style.</p> <code>'dashed'</code> <code>horizontalalignment</code> <code>str</code> <p>The horizontal alignment relative to the anchor point.</p> <code>'center'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import axvline_median\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; axvline_median(ax, median=42.0)\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.axvline_quantile","title":"flamme.plot.utils.axvline_quantile","text":"<pre><code>axvline_quantile(\n    ax: Axes,\n    quantile: float,\n    label: str,\n    color: str = \"black\",\n    linestyle: str = \"dashed\",\n    horizontalalignment: str = \"center\",\n) -&gt; None\n</code></pre> <p>Add a vertical line to represent a quantile value.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The Axes object that encapsulates all the elements of an individual (sub-)plot in a figure.</p> required <code>quantile</code> <code>float</code> <p>The quantile value.</p> required <code>label</code> <code>str</code> <p>The associated label to show on the plot.</p> required <code>color</code> <code>str</code> <p>The line color.</p> <code>'black'</code> <code>linestyle</code> <code>str</code> <p>The line style.</p> <code>'dashed'</code> <code>horizontalalignment</code> <code>str</code> <p>The horizontal alignment relative to the anchor point.</p> <code>'center'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import axvline_quantile\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; axvline_quantile(ax, quantile=42.0, label=\" q0.9\")\n</code></pre>"},{"location":"refs/plot/#flamme.plot.utils.readable_xticklabels","title":"flamme.plot.utils.readable_xticklabels","text":"<pre><code>readable_xticklabels(\n    ax: Axes,\n    max_num_xticks: int = 100,\n    xticklabel_max_len: int = 20,\n    xticklabel_min: int = 10,\n) -&gt; None\n</code></pre> <p>Update the tick labels to make them easier to read, in particular if the tick labels are dense.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The figure axes to update.</p> required <code>max_num_xticks</code> <code>int</code> <p>The maximum number of ticks to show in the figure.</p> <code>100</code> <code>xticklabel_max_len</code> <code>int</code> <p>If a tick label has a length greater than this value, the tick labels are rotated vertically.</p> <code>20</code> <code>xticklabel_min</code> <code>int</code> <p>If the number of ticks is lower than this number the tick labels are rotated vertically.</p> <code>10</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from matplotlib import pyplot as plt\n&gt;&gt;&gt; from flamme.plot.utils import readable_xticklabels\n&gt;&gt;&gt; fig, ax = plt.subplots()\n&gt;&gt;&gt; ax.hist(np.arange(10), bins=10)\n&gt;&gt;&gt; readable_xticklabels(ax)\n</code></pre>"},{"location":"refs/reporter/","title":"reporter","text":""},{"location":"refs/reporter/#flamme.reporter","title":"flamme.reporter","text":"<p>Contain reporters.</p>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter","title":"flamme.reporter.BaseReporter","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to compute a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): ParquetIngestor(path=/path/to/data.parquet)\n  (transformer): SequentialTransformer()\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter.compute","title":"flamme.reporter.BaseReporter.compute","text":"<pre><code>compute() -&gt; None\n</code></pre> <p>Generate a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(figsize=None),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.NoRepeatReporter","title":"flamme.reporter.NoRepeatReporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a reporter that computes the report only once.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>The reporter or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter, NoRepeatReporter\n&gt;&gt;&gt; reporter = NoRepeatReporter(\n...     reporter=Reporter(\n...         ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...         transformer=SequentialTransformer(transformers=[]),\n...         analyzer=NullValueAnalyzer(),\n...         report_path=\"/path/to/report.html\",\n...     ),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.Reporter","title":"flamme.reporter.Reporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a simple reporter.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The ingestor or its configuration.</p> required <code>transformer</code> <code>BaseTransformer | dict</code> <p>The data transformer or its configuration.</p> required <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The analyzer or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>6</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; from grizz.transformer import SequentialTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.is_reporter_config","title":"flamme.reporter.is_reporter_config","text":"<pre><code>is_reporter_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseReporter</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseReporter</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import is_reporter_config\n&gt;&gt;&gt; is_reporter_config(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"grizz.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\"_target_\": \"grizz.transformer.DropDuplicate\"},\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.setup_reporter","title":"flamme.reporter.setup_reporter","text":"<pre><code>setup_reporter(\n    reporter: BaseReporter | dict,\n) -&gt; BaseReporter\n</code></pre> <p>Set up a reporter.</p> <p>The reporter is instantiated from its configuration by using the <code>BaseReporter</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>Specifies an reporter or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseReporter</code> <p>An instantiated reporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import setup_reporter\n&gt;&gt;&gt; reporter = setup_reporter(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"grizz.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\"_target_\": \"grizz.transformer.DropDuplicate\"},\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): CsvIngestor(path=/path/to/data.csv)\n  (transformer): DropDuplicateTransformer(columns=None, ignore_missing=False)\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n</code></pre>"},{"location":"refs/schema/","title":"schema","text":""},{"location":"refs/schema/#flamme.schema","title":"flamme.schema","text":"<p>Contain functionalities to manipulate DataFrame's schemas.</p>"},{"location":"refs/schema/#flamme.schema.reader","title":"flamme.schema.reader","text":"<p>Contain schema readers.</p>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader","title":"flamme.schema.reader.BaseSchemaReader","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...             \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...         }\n...     ).write_parquet(path)\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: large_string\ncol3: double\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader.read","title":"flamme.schema.reader.BaseSchemaReader.read","text":"<pre><code>read() -&gt; Schema\n</code></pre> <p>Read the schema associated to a DataFrame.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>The ingested DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...             \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...         }\n...     ).write_parquet(path)\n...     reader = ParquetSchemaReader(path)\n...     schema = reader.read()\n...     schema\n...\ncol1: int64\ncol2: large_string\ncol3: double\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ClickHouseSchemaReader","title":"flamme.schema.reader.ClickHouseSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The clickhouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import ClickHouseSchemaReader\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; reader = ClickHouseSchemaReader(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; schema = reader.read()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ParquetSchemaReader","title":"flamme.schema.reader.ParquetSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a parquet schema reader.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...             \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...         }\n...     ).write_parquet(path)\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: large_string\ncol3: double\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.SchemaReader","title":"flamme.schema.reader.SchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.schema.reader import SchemaReader\n&gt;&gt;&gt; reader = SchemaReader(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [1.1, 2.2, 3.3, 4.4, 5.5],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         },\n...         schema={\"col1\": pl.Int64, \"col2\": pl.Float64, \"col4\": pl.String},\n...     )\n... )\n&gt;&gt;&gt; reader\nSchemaReader(shape=(5, 3))\n&gt;&gt;&gt; schema = reader.read()\n&gt;&gt;&gt; schema\ncol1: int64\ncol2: double\ncol4: large_string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.is_schema_reader_config","title":"flamme.schema.reader.is_schema_reader_config","text":"<pre><code>is_schema_reader_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseSchemaReader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseSchemaReader</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import is_schema_reader_config\n&gt;&gt;&gt; is_schema_reader_config(\n...     {\n...         \"_target_\": \"flamme.schema.reader.ParquetSchemaReader\",\n...         \"path\": \"/path/to/data.parquet\",\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.setup_schema_reader","title":"flamme.schema.reader.setup_schema_reader","text":"<pre><code>setup_schema_reader(\n    reader: BaseSchemaReader | dict,\n) -&gt; BaseSchemaReader\n</code></pre> <p>Set up a schema reader.</p> <p>The reader is instantiated from its configuration by using the <code>BaseSchemaReader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reader</code> <code>BaseSchemaReader | dict</code> <p>Specifies a schema reader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseSchemaReader</code> <p>An instantiated schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import setup_schema_reader\n&gt;&gt;&gt; reader = setup_schema_reader(\n...     {\n...         \"_target_\": \"flamme.schema.reader.ParquetSchemaReader\",\n...         \"path\": \"/path/to/data.parquet\",\n...     }\n... )\n&gt;&gt;&gt; reader\nParquetSchemaReader(path=.../data.parquet)\n</code></pre>"},{"location":"refs/section/","title":"section","text":""},{"location":"refs/section/#flamme.section","title":"flamme.section","text":"<p>Contain sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection","title":"flamme.section.BaseSection","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to manage sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection.get_statistics","title":"flamme.section.BaseSection.get_statistics  <code>abstractmethod</code>","text":"<pre><code>get_statistics() -&gt; dict\n</code></pre> <p>Return the statistics associated to the section.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The statistics.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_body","title":"flamme.section.BaseSection.render_html_body  <code>abstractmethod</code>","text":"<pre><code>render_html_body(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n) -&gt; str\n</code></pre> <p>Return the HTML body associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML body associated to the section.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_toc","title":"flamme.section.BaseSection.render_html_toc  <code>abstractmethod</code>","text":"<pre><code>render_html_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection","title":"flamme.section.ColumnContinuousAdvancedSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousAdvancedSection\n&gt;&gt;&gt; section = ColumnContinuousAdvancedSection(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousAdvancedSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'nunique': 102, 'num_non_nulls': 101, 'num_nulls': 2,\n 'mean': 50.0, 'std': 29.15..., 'skewness': 0.0, 'kurtosis': -1.20..., 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection.figsize","title":"flamme.section.ColumnContinuousAdvancedSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection","title":"flamme.section.ColumnContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousSection(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'nunique': 102, 'num_non_nulls': 101, 'num_nulls': 2,\n 'mean': 50.0, 'std': 29.15..., 'skewness': 0.0, 'kurtosis': -1.20..., 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection.figsize","title":"flamme.section.ColumnContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousTemporalDriftSection","title":"flamme.section.ColumnContinuousTemporalDriftSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal drift of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousTemporalDriftSection\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = pl.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(59),\n...         \"datetime\": pl.datetime_range(\n...             start=datetime(year=2018, month=1, day=1, tzinfo=timezone.utc),\n...             end=datetime(year=2018, month=3, day=1, tzinfo=timezone.utc),\n...             interval=\"1d\",\n...             closed=\"left\",\n...             eager=True,\n...         ),\n...     },\n...     schema={\n...         \"col\": pl.Float64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = ColumnContinuousTemporalDriftSection(\n...     frame=data, column=\"col\", dt_column=\"date\", period=\"1mo\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousTemporalDriftSection(\n  (column): col\n  (dt_column): date\n  (period): 1mo\n  (nbins): None\n  (density): False\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousTemporalDriftSection.figsize","title":"flamme.section.ColumnContinuousTemporalDriftSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection","title":"flamme.section.ColumnDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a discrete distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>null_values</code> <code>int</code> <p>The number of null values.</p> <code>0</code> <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import ColumnDiscreteSection\n&gt;&gt;&gt; section = ColumnDiscreteSection(counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\")\n&gt;&gt;&gt; section\nColumnDiscreteSection(\n  (null_values): 0\n  (column): col\n  (yscale): auto\n  (max_rows): 20\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)], 'null_values': 0, 'nunique': 3, 'total': 12}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection.figsize","title":"flamme.section.ColumnDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection","title":"flamme.section.ColumnTemporalContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnTemporalContinuousSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=1, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=2, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalContinuousSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection.figsize","title":"flamme.section.ColumnTemporalContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection","title":"flamme.section.ColumnTemporalDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column of the DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalDiscreteSection\n&gt;&gt;&gt; section = ColumnTemporalDiscreteSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 42, None, 42],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (proportion): False\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection.figsize","title":"flamme.section.ColumnTemporalDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalDriftDiscreteSection","title":"flamme.section.ColumnTemporalDriftDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal drift of a column with discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column of the DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalDriftDiscreteSection\n&gt;&gt;&gt; section = ColumnTemporalDriftDiscreteSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 42, None, 42],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalDriftDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (proportion): False\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalDriftDiscreteSection.figsize","title":"flamme.section.ColumnTemporalDriftDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection","title":"flamme.section.ColumnTemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalNullValueSection\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = ColumnTemporalNullValueSection(\n...     frame=frame, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; section\nColumnTemporalNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.columns","title":"flamme.section.ColumnTemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.dt_column","title":"flamme.section.ColumnTemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.figsize","title":"flamme.section.ColumnTemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.frame","title":"flamme.section.ColumnTemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.ncols","title":"flamme.section.ColumnTemporalNullValueSection.ncols  <code>property</code>","text":"<pre><code>ncols: int\n</code></pre> <p>The number of columns to show the figures.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.period","title":"flamme.section.ColumnTemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.ContentSection","title":"flamme.section.ContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import ContentSection\n&gt;&gt;&gt; section = ContentSection(content=\"meow\")\n&gt;&gt;&gt; section\nContentSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.DataFrameSummarySection","title":"flamme.section.DataFrameSummarySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that returns a summary of a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import DataFrameSummarySection\n&gt;&gt;&gt; section = DataFrameSummarySection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1.2, 4.2, 4.2, 2.2],\n...             \"col2\": [1, 1, 1, 1],\n...             \"col3\": [1, 2, 2, 2],\n...         },\n...         schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...     )\n... )\n&gt;&gt;&gt; section\nDataFrameSummarySection(top=5)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 0, 0), 'nunique': (3, 1, 2),\n 'dtypes': (Float64, Int64, Int64)}\n</code></pre>"},{"location":"refs/section/#flamme.section.DataFrameSummarySection.frame","title":"flamme.section.DataFrameSummarySection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.DataTypeSection","title":"flamme.section.DataTypeSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the data type of each column.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>dict[str, DataType]</code> <p>The data type for each column.</p> required <code>types</code> <code>dict[str, set]</code> <p>The types of the values in each column. A column can contain multiple types. The keys are the column names.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import DataTypeSection\n&gt;&gt;&gt; section = DataTypeSection(\n...     dtypes={\"float\": pl.Float64(), \"int\": pl.Int64(), \"str\": pl.String()},\n...     types={\"float\": {float}, \"int\": {int}, \"str\": {str, type(None)}},\n... )\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'float': Float64, 'int': Int64, 'str': String}\n  (types): {'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {...}}\n)\n&gt;&gt;&gt; section.get_statistics()\n{'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection","title":"flamme.section.DuplicatedRowSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import DuplicatedRowSection\n&gt;&gt;&gt; section = DuplicatedRowSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1.2, 4.2, 4.2, 2.2],\n...             \"col2\": [1, 1, 1, 1],\n...             \"col3\": [1, 2, 2, 2],\n...         },\n...         schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...     )\n... )\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.columns","title":"flamme.section.DuplicatedRowSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...] | None\n</code></pre> <p>Tuple or <code>None</code>: The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.figsize","title":"flamme.section.DuplicatedRowSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.frame","title":"flamme.section.DuplicatedRowSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.EmptySection","title":"flamme.section.EmptySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement an empty section.</p> <p>This section is implemented to deal with missing columns or to skip some analyses.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import EmptySection\n&gt;&gt;&gt; section = EmptySection()\n&gt;&gt;&gt; section\nEmptySection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MarkdownSection","title":"flamme.section.MarkdownSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that converts a markdown string into HTML.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown string to convert.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import MarkdownSection\n&gt;&gt;&gt; section = MarkdownSection(desc=\"meow\")\n&gt;&gt;&gt; section\nMarkdownSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MostFrequentValuesSection","title":"flamme.section.MostFrequentValuesSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the most frequent values for a given columns.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of occurrences for all values.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import MostFrequentValuesSection\n&gt;&gt;&gt; section = MostFrequentValuesSection(\n...     counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\"\n... )\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({'c': 6, 'a': 4, 'b': 2})\n  (column): col\n  (top): 100\n  (total): 12\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)]}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection","title":"flamme.section.NullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the number of null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>ndarray</code> <p>The number of null values for each column.</p> required <code>total_count</code> <code>ndarray</code> <p>The total number of values for each column.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import NullValueSection\n&gt;&gt;&gt; section = NullValueSection(\n...     columns=[\"col1\", \"col2\", \"col3\"],\n...     null_count=np.array([0, 1, 2]),\n...     total_count=np.array([5, 5, 5]),\n... )\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('col1', 'col2', 'col3')\n  (null_count): array([0, 1, 2])\n  (total_count): array([5, 5, 5])\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 1, 2), 'total_count': (5, 5, 5)}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection.columns","title":"flamme.section.NullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.figsize","title":"flamme.section.NullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.null_count","title":"flamme.section.NullValueSection.null_count  <code>property</code>","text":"<pre><code>null_count: ndarray\n</code></pre> <p>The number of null values for each column.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.total_count","title":"flamme.section.NullValueSection.total_count  <code>property</code>","text":"<pre><code>total_count: ndarray\n</code></pre> <p>The total number of values for each column.</p>"},{"location":"refs/section/#flamme.section.SectionDict","title":"flamme.section.SectionDict","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to manage a dictionary of sections.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>dict[str, BaseSection]</code> <p>The dictionary of sections.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import SectionDict, ContentSection, TemporalRowCountSection\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ]\n...     },\n...     schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = SectionDict(\n...     {\n...         \"content\": ContentSection(\"meow\"),\n...         \"rows\": TemporalRowCountSection(frame, dt_column=\"datetime\", period=\"1mo\"),\n...     }\n... )\n&gt;&gt;&gt; section\nSectionDict(\n  (content): ContentSection()\n  (rows): TemporalRowCountSection(dt_column=datetime, period=1mo, figsize=None)\n)\n&gt;&gt;&gt; section.get_statistics()\n{'content': {}, 'rows': {}}\n</code></pre>"},{"location":"refs/section/#flamme.section.TableOfContentSection","title":"flamme.section.TableOfContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a wrapper section that generates a table of content before the section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseSection</code> <p>The section.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import TableOfContentSection, DuplicatedRowSection\n&gt;&gt;&gt; section = TableOfContentSection(\n...     DuplicatedRowSection(\n...         frame=pl.DataFrame(\n...             {\n...                 \"col1\": [1.2, 4.2, 4.2, 2.2],\n...                 \"col2\": [1, 1, 1, 1],\n...                 \"col3\": [1, 2, 2, 2],\n...             },\n...             schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...         )\n...     )\n... )\n&gt;&gt;&gt; section\nTableOfContentSection(\n  (section): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection","title":"flamme.section.TemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import TemporalNullValueSection\n&gt;&gt;&gt; section = TemporalNullValueSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, 1.0, 0.0, 1.0],\n...             \"col2\": [None, 1, 0, None],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     columns=[\"col1\", \"col2\"],\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nTemporalNullValueSection(\n  (columns): ('col1', 'col2')\n  (dt_column): datetime\n  (period): 1mo\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.columns","title":"flamme.section.TemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.dt_column","title":"flamme.section.TemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.figsize","title":"flamme.section.TemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.frame","title":"flamme.section.TemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.period","title":"flamme.section.TemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection","title":"flamme.section.TemporalRowCountSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import TemporalRowCountSection\n&gt;&gt;&gt; section = TemporalRowCountSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ]\n...         },\n...         schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nTemporalRowCountSection(dt_column=datetime, period=1mo, figsize=None)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.dt_column","title":"flamme.section.TemporalRowCountSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.figsize","title":"flamme.section.TemporalRowCountSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.frame","title":"flamme.section.TemporalRowCountSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.period","title":"flamme.section.TemporalRowCountSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.content","title":"flamme.section.content","text":"<p>Contain the implementation of a section that generates the given custom content.</p>"},{"location":"refs/section/#flamme.section.content.ContentSection","title":"flamme.section.content.ContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import ContentSection\n&gt;&gt;&gt; section = ContentSection(content=\"meow\")\n&gt;&gt;&gt; section\nContentSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.content.create_section_template","title":"flamme.section.content.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.content import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous","title":"flamme.section.continuous","text":"<p>Contain the implementation of a section to analyze a column with continuous values.</p>"},{"location":"refs/section/#flamme.section.continuous.ColumnContinuousSection","title":"flamme.section.continuous.ColumnContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousSection(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'nunique': 102, 'num_non_nulls': 101, 'num_nulls': 2,\n 'mean': 50.0, 'std': 29.15..., 'skewness': 0.0, 'kurtosis': -1.20..., 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1}\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous.ColumnContinuousSection.figsize","title":"flamme.section.continuous.ColumnContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.continuous.create_boxplot_figure","title":"flamme.section.continuous.create_boxplot_figure","text":"<pre><code>create_boxplot_figure(\n    series: Series,\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return a boxplot figure.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous import create_boxplot_figure\n&gt;&gt;&gt; fig = create_boxplot_figure(series=pl.Series([None, *list(range(101)), None]))\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous.create_histogram_figure","title":"flamme.section.continuous.create_histogram_figure","text":"<pre><code>create_histogram_figure(\n    series: Series,\n    column: str,\n    nbins: int | None = None,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return a histogram figure.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous import create_histogram_figure\n&gt;&gt;&gt; fig = create_histogram_figure(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous.create_section_template","title":"flamme.section.continuous.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.continuous import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous.create_stats_table","title":"flamme.section.continuous.create_stats_table","text":"<pre><code>create_stats_table(stats: dict, column: str) -&gt; str\n</code></pre> <p>Create the HTML code of the table with statistics.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>dict</code> <p>Specifies a dictionary with the statistics.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.continuous import create_stats_table\n&gt;&gt;&gt; table = create_stats_table(\n...     column=\"col\",\n...     stats={\n...         \"count\": 101,\n...         \"nunique\": 101,\n...         \"num_non_nulls\": 101,\n...         \"num_nulls\": 0,\n...         \"mean\": 50.0,\n...         \"std\": 29.15,\n...         \"skewness\": 0.0,\n...         \"kurtosis\": -1.20,\n...         \"min\": 0.0,\n...         \"q001\": 0.1,\n...         \"q01\": 1.0,\n...         \"q05\": 5.0,\n...         \"q10\": 10.0,\n...         \"q25\": 25.0,\n...         \"median\": 50.0,\n...         \"q75\": 75.0,\n...         \"q90\": 90.0,\n...         \"q95\": 95.0,\n...         \"q99\": 99.0,\n...         \"q999\": 99.9,\n...         \"max\": 100.0,\n...         \"&gt;0\": 100,\n...         \"&lt;0\": 0,\n...         \"=0\": 1,\n...     },\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous.to_array","title":"flamme.section.continuous.to_array","text":"<pre><code>to_array(series: Series) -&gt; ndarray\n</code></pre> <p>Convert a series to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series to convert.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The converted array.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous import to_array\n&gt;&gt;&gt; array = to_array(series=pl.Series([None, *list(range(5)), None]))\n&gt;&gt;&gt; array\narray([0, 1, 2, 3, 4])\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_advanced","title":"flamme.section.continuous_advanced","text":"<p>Contain the implementation of a section to analyze a column with continuous values.</p>"},{"location":"refs/section/#flamme.section.continuous_advanced.ColumnContinuousAdvancedSection","title":"flamme.section.continuous_advanced.ColumnContinuousAdvancedSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousAdvancedSection\n&gt;&gt;&gt; section = ColumnContinuousAdvancedSection(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousAdvancedSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'nunique': 102, 'num_non_nulls': 101, 'num_nulls': 2,\n 'mean': 50.0, 'std': 29.15..., 'skewness': 0.0, 'kurtosis': -1.20..., 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1}\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_advanced.ColumnContinuousAdvancedSection.figsize","title":"flamme.section.continuous_advanced.ColumnContinuousAdvancedSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.continuous_advanced.create_histogram_range_figure","title":"flamme.section.continuous_advanced.create_histogram_range_figure","text":"<pre><code>create_histogram_range_figure(\n    series: Series,\n    column: str,\n    nbins: int | None = None,\n    yscale: str = \"auto\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Create a histogram figure.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous_advanced import create_histogram_range_figure\n&gt;&gt;&gt; fig = create_histogram_range_figure(\n...     series=pl.Series([None, *list(range(101)), None]), column=\"col\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_advanced.create_section_template","title":"flamme.section.continuous_advanced.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.continuous_advanced import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_drift","title":"flamme.section.continuous_drift","text":"<p>Contain the implementation of a section to analyze the temporal drift of a column with continuous values.</p>"},{"location":"refs/section/#flamme.section.continuous_drift.ColumnContinuousTemporalDriftSection","title":"flamme.section.continuous_drift.ColumnContinuousTemporalDriftSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal drift of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousTemporalDriftSection\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = pl.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(59),\n...         \"datetime\": pl.datetime_range(\n...             start=datetime(year=2018, month=1, day=1, tzinfo=timezone.utc),\n...             end=datetime(year=2018, month=3, day=1, tzinfo=timezone.utc),\n...             interval=\"1d\",\n...             closed=\"left\",\n...             eager=True,\n...         ),\n...     },\n...     schema={\n...         \"col\": pl.Float64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = ColumnContinuousTemporalDriftSection(\n...     frame=data, column=\"col\", dt_column=\"date\", period=\"1mo\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousTemporalDriftSection(\n  (column): col\n  (dt_column): date\n  (period): 1mo\n  (nbins): None\n  (density): False\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_drift.ColumnContinuousTemporalDriftSection.figsize","title":"flamme.section.continuous_drift.ColumnContinuousTemporalDriftSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.continuous_drift.create_section_template","title":"flamme.section.continuous_drift.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.continuous_drift import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_drift.create_temporal_drift_figure","title":"flamme.section.continuous_drift.create_temporal_drift_figure","text":"<pre><code>create_temporal_drift_figure(\n    frame: DataFrame,\n    column: str,\n    dt_column: str,\n    period: str,\n    nbins: int | None = None,\n    density: bool = False,\n    yscale: str = \"linear\",\n    xmin: float | str | None = None,\n    xmax: float | str | None = None,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return the figure to analyze the temporal drift.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>density</code> <code>bool</code> <p>If True, draw and return a probability density: each bin will display the bin's raw count divided by the total number of counts and the bin width, so that the area under the histogram integrates to 1.</p> <code>False</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'linear'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure or <code>None</code> if there is no valid data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous_drift import create_temporal_drift_figure\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; data = pl.DataFrame(\n...     {\n...         \"col\": rng.standard_normal(59),\n...         \"datetime\": pl.datetime_range(\n...             start=datetime(year=2018, month=1, day=1, tzinfo=timezone.utc),\n...             end=datetime(year=2018, month=3, day=1, tzinfo=timezone.utc),\n...             interval=\"1d\",\n...             closed=\"left\",\n...             eager=True,\n...         ),\n...     },\n...     schema={\n...         \"col\": pl.Float64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; fig = create_temporal_drift_figure(\n...     frame=data, column=\"col\", dt_column=\"date\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_temp","title":"flamme.section.continuous_temp","text":"<p>Contain the implementation of a section to analyze the temporal distribution of a column with continuous values.</p>"},{"location":"refs/section/#flamme.section.continuous_temp.ColumnTemporalContinuousSection","title":"flamme.section.continuous_temp.ColumnTemporalContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnTemporalContinuousSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=1, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=2, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalContinuousSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_temp.ColumnTemporalContinuousSection.figsize","title":"flamme.section.continuous_temp.ColumnTemporalContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.continuous_temp.create_section_template","title":"flamme.section.continuous_temp.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.continuous_temp import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_temp.create_temporal_figure","title":"flamme.section.continuous_temp.create_temporal_figure","text":"<pre><code>create_temporal_figure(\n    frame: DataFrame,\n    column: str,\n    dt_column: str,\n    period: str,\n    yscale: str = \"auto\",\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Create a figure with the temporal value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous_temp import create_temporal_figure\n&gt;&gt;&gt; fig = create_temporal_figure(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=1, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=2, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_temp.create_temporal_table","title":"flamme.section.continuous_temp.create_temporal_table","text":"<pre><code>create_temporal_table(\n    frame: DataFrame,\n    column: str,\n    dt_column: str,\n    period: str,\n) -&gt; str\n</code></pre> <p>Return a HTML representation of a table with some statistics about the temporal value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous_temp import create_temporal_table\n&gt;&gt;&gt; table = create_temporal_table(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=1, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=2, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.continuous_temp.create_temporal_table_row","title":"flamme.section.continuous_temp.create_temporal_table_row","text":"<pre><code>create_temporal_table_row(stats: dict) -&gt; str\n</code></pre> <p>Return the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>dict</code> <p>The statistics for the row.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.continuous_temp import create_temporal_table_row\n&gt;&gt;&gt; row = create_temporal_table_row(\n...     stats={\n...         \"step\": \"2020-01-01\",\n...         \"count\": 101,\n...         \"nunique\": 101,\n...         \"mean\": 50.0,\n...         \"std\": 29.300170647967224,\n...         \"min\": 0.0,\n...         \"q01\": 1.0,\n...         \"q05\": 5.0,\n...         \"q10\": 10.0,\n...         \"q25\": 25.0,\n...         \"median\": 50.0,\n...         \"q75\": 75.0,\n...         \"q90\": 90.0,\n...         \"q95\": 95.0,\n...         \"q99\": 99.0,\n...         \"max\": 100.0,\n...     }\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.count_rows","title":"flamme.section.count_rows","text":"<p>Contain the implementation of a section to count the number of rows for a given temporal window.</p>"},{"location":"refs/section/#flamme.section.count_rows.TemporalRowCountSection","title":"flamme.section.count_rows.TemporalRowCountSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import TemporalRowCountSection\n&gt;&gt;&gt; section = TemporalRowCountSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ]\n...         },\n...         schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nTemporalRowCountSection(dt_column=datetime, period=1mo, figsize=None)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.count_rows.TemporalRowCountSection.dt_column","title":"flamme.section.count_rows.TemporalRowCountSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.count_rows.TemporalRowCountSection.figsize","title":"flamme.section.count_rows.TemporalRowCountSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.count_rows.TemporalRowCountSection.frame","title":"flamme.section.count_rows.TemporalRowCountSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.count_rows.TemporalRowCountSection.period","title":"flamme.section.count_rows.TemporalRowCountSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.count_rows.create_section_template","title":"flamme.section.count_rows.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.count_rows import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.count_rows.create_temporal_count_figure","title":"flamme.section.count_rows.create_temporal_count_figure","text":"<pre><code>create_temporal_count_figure(\n    frame: DataFrame,\n    dt_column: str,\n    period: str,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return a figure with number of rows per temporal windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.count_rows import create_temporal_count_figure\n&gt;&gt;&gt; fig = create_temporal_count_figure(\n...     frame=pl.DataFrame(\n...         {\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ]\n...         },\n...         schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.count_rows.create_temporal_count_table","title":"flamme.section.count_rows.create_temporal_count_table","text":"<pre><code>create_temporal_count_table(\n    frame: DataFrame, dt_column: str, period: str\n) -&gt; str\n</code></pre> <p>Return a HTML representation of a figure with number of rows per temporal windows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.count_rows import create_temporal_count_table\n&gt;&gt;&gt; table = create_temporal_count_table(\n...     frame=pl.DataFrame(\n...         {\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ]\n...         },\n...         schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.count_rows.create_temporal_count_table_row","title":"flamme.section.count_rows.create_temporal_count_table_row","text":"<pre><code>create_temporal_count_table_row(\n    label: str, num_rows: int\n) -&gt; str\n</code></pre> <p>Return the HTML code of a table row.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label i.e. temporal window.</p> required <code>num_rows</code> <code>int</code> <p>The number of rows for the given temporal window.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.count_rows import create_temporal_count_table_row\n&gt;&gt;&gt; row = create_temporal_count_table_row(label=\"meow\", num_rows=42)\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete","title":"flamme.section.discrete","text":"<p>Contain the implementation of a section to analyze a column with discrete values.</p>"},{"location":"refs/section/#flamme.section.discrete.ColumnDiscreteSection","title":"flamme.section.discrete.ColumnDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a discrete distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>null_values</code> <code>int</code> <p>The number of null values.</p> <code>0</code> <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import ColumnDiscreteSection\n&gt;&gt;&gt; section = ColumnDiscreteSection(counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\")\n&gt;&gt;&gt; section\nColumnDiscreteSection(\n  (null_values): 0\n  (column): col\n  (yscale): auto\n  (max_rows): 20\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)], 'null_values': 0, 'nunique': 3, 'total': 12}\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete.ColumnDiscreteSection.figsize","title":"flamme.section.discrete.ColumnDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.discrete.create_histogram","title":"flamme.section.discrete.create_histogram","text":"<pre><code>create_histogram(\n    column: str,\n    names: Sequence,\n    counts: Sequence[int],\n    yscale: str = \"auto\",\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return a figure with the histogram of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>names</code> <code>Sequence</code> <p>The name of the values to plot.</p> required <code>counts</code> <code>Sequence[int]</code> <p>The number of value occurrences.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.discrete import create_histogram\n&gt;&gt;&gt; fig = create_histogram(\n...     column=\"col\", names=[\"a\", \"b\", \"c\", \"d\"], counts=[5, 100, 42, 27]\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete.create_histogram_section","title":"flamme.section.discrete.create_histogram_section","text":"<pre><code>create_histogram_section(\n    counter: Counter,\n    column: str = \"N/A\",\n    yscale: str = \"auto\",\n    figsize: tuple[float, float] | None = None,\n) -&gt; str\n</code></pre> <p>Return the histogram section.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The histogram section.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section.discrete import create_histogram_section\n&gt;&gt;&gt; section = create_histogram_section(\n...     counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete.create_section_template","title":"flamme.section.discrete.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.discrete import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete.create_table","title":"flamme.section.discrete.create_table","text":"<pre><code>create_table(\n    counter: Counter,\n    column: str = \"N/A\",\n    max_rows: int = 20,\n) -&gt; str\n</code></pre> <p>Return a HTML table with the discrete distribution.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <p>Returns:</p> Type Description <code>str</code> <p>The generated table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section.discrete import create_table_row\n&gt;&gt;&gt; table = create_table(counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\")\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete.create_table_row","title":"flamme.section.discrete.create_table_row","text":"<pre><code>create_table_row(column: str, count: int) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>count</code> <code>int</code> <p>The count for the column.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.discrete import create_table_row\n&gt;&gt;&gt; row = create_table_row(column=\"col\", count=5)\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete_temp","title":"flamme.section.discrete_temp","text":"<p>Contain the implementation of a section to analyze the temporal distribution of a column with discrete values.</p>"},{"location":"refs/section/#flamme.section.discrete_temp.ColumnTemporalDiscreteSection","title":"flamme.section.discrete_temp.ColumnTemporalDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column of the DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalDiscreteSection\n&gt;&gt;&gt; section = ColumnTemporalDiscreteSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 42, None, 42],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): 1mo\n  (proportion): False\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete_temp.ColumnTemporalDiscreteSection.figsize","title":"flamme.section.discrete_temp.ColumnTemporalDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.discrete_temp.create_section_template","title":"flamme.section.discrete_temp.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.discrete_temp import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.discrete_temp.create_temporal_figure","title":"flamme.section.discrete_temp.create_temporal_figure","text":"<pre><code>create_temporal_figure(\n    frame: DataFrame,\n    column: str,\n    dt_column: str,\n    period: str,\n    proportion: bool = False,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Create a figure with the temporal value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>proportion</code> <code>bool</code> <p>If <code>True</code>, it plots the normalized number of occurrences for each step.</p> <code>False</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure or None if the data is empty.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.discrete_temp import create_temporal_figure\n&gt;&gt;&gt; fig = create_temporal_figure(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 42, None, 42],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.dtype","title":"flamme.section.dtype","text":"<p>Contain the implementation of a section to analyze the data types of each column.</p>"},{"location":"refs/section/#flamme.section.dtype.DataTypeSection","title":"flamme.section.dtype.DataTypeSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the data type of each column.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>dict[str, DataType]</code> <p>The data type for each column.</p> required <code>types</code> <code>dict[str, set]</code> <p>The types of the values in each column. A column can contain multiple types. The keys are the column names.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import DataTypeSection\n&gt;&gt;&gt; section = DataTypeSection(\n...     dtypes={\"float\": pl.Float64(), \"int\": pl.Int64(), \"str\": pl.String()},\n...     types={\"float\": {float}, \"int\": {int}, \"str\": {str, type(None)}},\n... )\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'float': Float64, 'int': Int64, 'str': String}\n  (types): {'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {...}}\n)\n&gt;&gt;&gt; section.get_statistics()\n{'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n</code></pre>"},{"location":"refs/section/#flamme.section.dtype.create_section_template","title":"flamme.section.dtype.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.dtype import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.dtype.create_table","title":"flamme.section.dtype.create_table","text":"<pre><code>create_table(\n    dtypes: dict[str, DataType], types: dict[str, set]\n) -&gt; str\n</code></pre> <p>Return a HTML table with the data types information.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>dict[str, DataType]</code> <p>The data type for each column.</p> required <code>types</code> <code>dict[str, set]</code> <p>The types of the values in each column. A column can contain multiple types. The keys are the column names.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated HTML table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.dtype import create_table_row\n&gt;&gt;&gt; table = create_table(\n...     dtypes={\"float\": pl.Float64(), \"int\": pl.Int64(), \"str\": pl.String()},\n...     types={\"float\": {float}, \"int\": {int}, \"str\": {str, type(None)}},\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.dtype.create_table_row","title":"flamme.section.dtype.create_table_row","text":"<pre><code>create_table_row(\n    column: str, dtype: DataType, types: set[type]\n) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>dtype</code> <code>DataType</code> <p>The column data type.</p> required <code>types</code> <code>set[type]</code> <p>The types in th column.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.dtype import create_table_row\n&gt;&gt;&gt; row = create_table_row(column=\"col\", dtype=pl.Int64(), types={int})\n</code></pre>"},{"location":"refs/section/#flamme.section.duplicate","title":"flamme.section.duplicate","text":"<p>Contain the implementation of a section to analyze the duplicate values.</p>"},{"location":"refs/section/#flamme.section.duplicate.DuplicatedRowSection","title":"flamme.section.duplicate.DuplicatedRowSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import DuplicatedRowSection\n&gt;&gt;&gt; section = DuplicatedRowSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1.2, 4.2, 4.2, 2.2],\n...             \"col2\": [1, 1, 1, 1],\n...             \"col3\": [1, 2, 2, 2],\n...         },\n...         schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...     )\n... )\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (frame): (4, 3)\n  (columns): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.duplicate.DuplicatedRowSection.columns","title":"flamme.section.duplicate.DuplicatedRowSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...] | None\n</code></pre> <p>Tuple or <code>None</code>: The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.duplicate.DuplicatedRowSection.figsize","title":"flamme.section.duplicate.DuplicatedRowSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.duplicate.DuplicatedRowSection.frame","title":"flamme.section.duplicate.DuplicatedRowSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.duplicate.create_duplicate_table","title":"flamme.section.duplicate.create_duplicate_table","text":"<pre><code>create_duplicate_table(\n    num_rows: int, num_unique_rows: int\n) -&gt; str\n</code></pre> <p>Return a HTML table with information about duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>num_rows</code> <code>int</code> <p>The number of rows.</p> required <code>num_unique_rows</code> <code>int</code> <p>The number of unique rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML table with information about duplicated rows.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.duplicate import create_duplicate_table\n&gt;&gt;&gt; table = create_duplicate_table(num_rows=10, num_unique_rows=5)\n</code></pre>"},{"location":"refs/section/#flamme.section.duplicate.create_section_template","title":"flamme.section.duplicate.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.duplicate import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.empty","title":"flamme.section.empty","text":"<p>Contain the implementation of an empty section.</p>"},{"location":"refs/section/#flamme.section.empty.EmptySection","title":"flamme.section.empty.EmptySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement an empty section.</p> <p>This section is implemented to deal with missing columns or to skip some analyses.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import EmptySection\n&gt;&gt;&gt; section = EmptySection()\n&gt;&gt;&gt; section\nEmptySection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.frame_summary","title":"flamme.section.frame_summary","text":"<p>Contain the implementation of a section to generate a summary of a DataFrame.</p>"},{"location":"refs/section/#flamme.section.frame_summary.DataFrameSummarySection","title":"flamme.section.frame_summary.DataFrameSummarySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that returns a summary of a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import DataFrameSummarySection\n&gt;&gt;&gt; section = DataFrameSummarySection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1.2, 4.2, 4.2, 2.2],\n...             \"col2\": [1, 1, 1, 1],\n...             \"col3\": [1, 2, 2, 2],\n...         },\n...         schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...     )\n... )\n&gt;&gt;&gt; section\nDataFrameSummarySection(top=5)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 0, 0), 'nunique': (3, 1, 2),\n 'dtypes': (Float64, Int64, Int64)}\n</code></pre>"},{"location":"refs/section/#flamme.section.frame_summary.DataFrameSummarySection.frame","title":"flamme.section.frame_summary.DataFrameSummarySection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.frame_summary.create_section_template","title":"flamme.section.frame_summary.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.frame_summary import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.frame_summary.create_table","title":"flamme.section.frame_summary.create_table","text":"<pre><code>create_table(\n    columns: Sequence[str],\n    null_count: Sequence[int],\n    nunique: Sequence[int],\n    dtypes: Sequence[DataType],\n    most_frequent_values: Sequence[\n        Sequence[tuple[Any, int]]\n    ],\n    total: int,\n) -&gt; str\n</code></pre> <p>Return a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>Sequence[int]</code> <p>The number of null values for each column.</p> required <code>nunique</code> <code>Sequence[int]</code> <p>The number of unique values for each column.</p> required <code>dtypes</code> <code>Sequence[DataType]</code> <p>The data type for each column.</p> required <code>most_frequent_values</code> <code>Sequence[Sequence[tuple[Any, int]]]</code> <p>The most frequent values for each column.</p> required <code>total</code> <code>int</code> <p>The total number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.frame_summary import create_table_row\n&gt;&gt;&gt; row = create_table(\n...     columns=[\"float\", \"int\", \"str\"],\n...     null_count=(1, 0, 2),\n...     nunique=(5, 2, 4),\n...     dtypes=(pl.Float64(), pl.Int64(), pl.String()),\n...     most_frequent_values=(\n...         ((2.2, 2), (1.2, 1), (4.2, 1), (None, 1), (1.0, 1)),\n...         ((1, 5), (0, 1)),\n...         ((\"B\", 2), (None, 2), (\"A\", 1), (\"C\", 1)),\n...     ),\n...     total=42,\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.frame_summary.create_table_row","title":"flamme.section.frame_summary.create_table_row","text":"<pre><code>create_table_row(\n    column: str,\n    null: int,\n    nunique: int,\n    dtype: DataType,\n    most_frequent_values: Sequence[tuple[Any, int]],\n    total: int,\n) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>null</code> <code>int</code> <p>The number of null values.</p> required <code>nunique</code> <code>int</code> <p>The number of unique values.</p> required <code>dtype</code> <code>DataType</code> <p>The data type of the column.</p> required <code>most_frequent_values</code> <code>Sequence[tuple[Any, int]]</code> <p>The most frequent values.</p> required <code>total</code> <code>int</code> <p>The total number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.frame_summary import create_table_row\n&gt;&gt;&gt; row = create_table_row(\n...     column=\"col\",\n...     null=5,\n...     nunique=42,\n...     dtype=pl.Float64(),\n...     most_frequent_values=[(\"C\", 12), (\"A\", 5), (\"B\", 4)],\n...     total=100,\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.mapping","title":"flamme.section.mapping","text":"<p>Contain the implementation of a section to manage a dictionary of sections.</p>"},{"location":"refs/section/#flamme.section.mapping.SectionDict","title":"flamme.section.mapping.SectionDict","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to manage a dictionary of sections.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>dict[str, BaseSection]</code> <p>The dictionary of sections.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import SectionDict, ContentSection, TemporalRowCountSection\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...             datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ]\n...     },\n...     schema={\"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\")},\n... )\n&gt;&gt;&gt; section = SectionDict(\n...     {\n...         \"content\": ContentSection(\"meow\"),\n...         \"rows\": TemporalRowCountSection(frame, dt_column=\"datetime\", period=\"1mo\"),\n...     }\n... )\n&gt;&gt;&gt; section\nSectionDict(\n  (content): ContentSection()\n  (rows): TemporalRowCountSection(dt_column=datetime, period=1mo, figsize=None)\n)\n&gt;&gt;&gt; section.get_statistics()\n{'content': {}, 'rows': {}}\n</code></pre>"},{"location":"refs/section/#flamme.section.markdown","title":"flamme.section.markdown","text":"<p>Contain the implementation of a section to convert a markdown string into HTML.</p>"},{"location":"refs/section/#flamme.section.markdown.MarkdownSection","title":"flamme.section.markdown.MarkdownSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that converts a markdown string into HTML.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown string to convert.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import MarkdownSection\n&gt;&gt;&gt; section = MarkdownSection(desc=\"meow\")\n&gt;&gt;&gt; section\nMarkdownSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.markdown.create_section_template","title":"flamme.section.markdown.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.markdown import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.most_frequent","title":"flamme.section.most_frequent","text":"<p>Contain the implementation of a section to analyze the most frequent values for a given columns.</p>"},{"location":"refs/section/#flamme.section.most_frequent.MostFrequentValuesSection","title":"flamme.section.most_frequent.MostFrequentValuesSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the most frequent values for a given columns.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of occurrences for all values.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import MostFrequentValuesSection\n&gt;&gt;&gt; section = MostFrequentValuesSection(\n...     counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\"\n... )\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({'c': 6, 'a': 4, 'b': 2})\n  (column): col\n  (top): 100\n  (total): 12\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)]}\n</code></pre>"},{"location":"refs/section/#flamme.section.most_frequent.create_section_template","title":"flamme.section.most_frequent.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.most_frequent import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.most_frequent.create_table","title":"flamme.section.most_frequent.create_table","text":"<pre><code>create_table(counter: Counter, top: int = 100) -&gt; str\n</code></pre> <p>Create a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of occurrences for all values.</p> required <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section.most_frequent import create_table\n&gt;&gt;&gt; table = create_table(Counter({\"a\": 4, \"b\": 2, \"c\": 6}))\n</code></pre>"},{"location":"refs/section/#flamme.section.most_frequent.create_table_row","title":"flamme.section.most_frequent.create_table_row","text":"<pre><code>create_table_row(\n    value: str, count: int, total: int, cumcount: int\n) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Specifies a string representation of the value.</p> required <code>count</code> <code>int</code> <p>The number of occurrences of the value.</p> required <code>total</code> <code>int</code> <p>The total number of occurrences.</p> required <code>cumcount</code> <code>int</code> <p>The cumulative number of occurrences.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.most_frequent import create_table_row\n&gt;&gt;&gt; row = create_table_row(value=\"A\", count=5, total=101, cumcount=42)\n</code></pre>"},{"location":"refs/section/#flamme.section.null","title":"flamme.section.null","text":"<p>Contain the implementation of sections to analyze the number null values.</p>"},{"location":"refs/section/#flamme.section.null.NullValueSection","title":"flamme.section.null.NullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the number of null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>ndarray</code> <p>The number of null values for each column.</p> required <code>total_count</code> <code>ndarray</code> <p>The total number of values for each column.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import NullValueSection\n&gt;&gt;&gt; section = NullValueSection(\n...     columns=[\"col1\", \"col2\", \"col3\"],\n...     null_count=np.array([0, 1, 2]),\n...     total_count=np.array([5, 5, 5]),\n... )\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('col1', 'col2', 'col3')\n  (null_count): array([0, 1, 2])\n  (total_count): array([5, 5, 5])\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 1, 2), 'total_count': (5, 5, 5)}\n</code></pre>"},{"location":"refs/section/#flamme.section.null.NullValueSection.columns","title":"flamme.section.null.NullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.null.NullValueSection.figsize","title":"flamme.section.null.NullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.null.NullValueSection.null_count","title":"flamme.section.null.NullValueSection.null_count  <code>property</code>","text":"<pre><code>null_count: ndarray\n</code></pre> <p>The number of null values for each column.</p>"},{"location":"refs/section/#flamme.section.null.NullValueSection.total_count","title":"flamme.section.null.NullValueSection.total_count  <code>property</code>","text":"<pre><code>total_count: ndarray\n</code></pre> <p>The total number of values for each column.</p>"},{"location":"refs/section/#flamme.section.null.create_bar_figure","title":"flamme.section.null.create_bar_figure","text":"<pre><code>create_bar_figure(\n    columns: Sequence[str],\n    null_count: Sequence[int],\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Return a bar figure with the distribution of null values per column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>Sequence[int]</code> <p>The number of null values for each column. It must have the same size as <code>columns</code>.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null import create_bar_figure\n&gt;&gt;&gt; fig = create_bar_figure(columns=[\"col1\", \"col2\", \"col3\"], null_count=[5, 10, 2])\n</code></pre>"},{"location":"refs/section/#flamme.section.null.create_section_template","title":"flamme.section.null.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.null.create_table","title":"flamme.section.null.create_table","text":"<pre><code>create_table(frame: DataFrame) -&gt; str\n</code></pre> <p>Return a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null import create_table\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"column\": [\"A\", \"B\", \"C\"], \"null\": [0, 1, 2], \"total\": [4, 4, 4]},\n...     schema={\"column\": pl.String, \"null\": pl.Int64, \"total\": pl.Int64},\n... )\n&gt;&gt;&gt; table = create_table(frame=frame)\n</code></pre>"},{"location":"refs/section/#flamme.section.null.create_table_row","title":"flamme.section.null.create_table_row","text":"<pre><code>create_table_row(\n    column: str, null_count: int, total_count: int\n) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>null_count</code> <code>int</code> <p>The number of null values.</p> required <code>total_count</code> <code>int</code> <p>The total number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null import create_table_row\n&gt;&gt;&gt; row = create_table_row(column=\"col\", null_count=5, total_count=101)\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp","title":"flamme.section.null_temp","text":"<p>Contain the implementation of a section to analyze the temporal distribution of null values for all columns.</p>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection","title":"flamme.section.null_temp.TemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import TemporalNullValueSection\n&gt;&gt;&gt; section = TemporalNullValueSection(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, 1.0, 0.0, 1.0],\n...             \"col2\": [None, 1, 0, None],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     columns=[\"col1\", \"col2\"],\n...     dt_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; section\nTemporalNullValueSection(\n  (columns): ('col1', 'col2')\n  (dt_column): datetime\n  (period): 1mo\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection.columns","title":"flamme.section.null_temp.TemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection.dt_column","title":"flamme.section.null_temp.TemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection.figsize","title":"flamme.section.null_temp.TemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection.frame","title":"flamme.section.null_temp.TemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.null_temp.TemporalNullValueSection.period","title":"flamme.section.null_temp.TemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.null_temp.create_section_template","title":"flamme.section.null_temp.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp.create_temporal_null_figure","title":"flamme.section.null_temp.create_temporal_null_figure","text":"<pre><code>create_temporal_null_figure(\n    frame: DataFrame,\n    columns: Sequence[str],\n    dt_column: str,\n    period: str,\n    figsize: tuple[float, float] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Create a figure with the temporal null value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure | None</code> <p>The generated figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp import create_temporal_null_figure\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [None, 1.0, 0.0, 1.0],\n...         \"col2\": [None, 1, 0, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"col1\": pl.Float64,\n...         \"col2\": pl.Int64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; fig = create_temporal_null_figure(\n...     frame=frame, columns=[\"col1\", \"col2\"], dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp.create_temporal_null_table","title":"flamme.section.null_temp.create_temporal_null_table","text":"<pre><code>create_temporal_null_table(\n    frame: DataFrame,\n    columns: Sequence[str],\n    dt_column: str,\n    period: str,\n) -&gt; str\n</code></pre> <p>Create a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp import create_temporal_null_table_row\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [None, 1.0, 0.0, 1.0],\n...         \"col2\": [None, 1, 0, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"col1\": pl.Float64,\n...         \"col2\": pl.Int64,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; table = create_temporal_null_table(\n...     frame=frame, columns=[\"col1\", \"col2\"], dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp.create_temporal_null_table_row","title":"flamme.section.null_temp.create_temporal_null_table_row","text":"<pre><code>create_temporal_null_table_row(\n    label: str, num_nulls: int, total: int\n) -&gt; str\n</code></pre> <p>Create the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the row.</p> required <code>num_nulls</code> <code>int</code> <p>The number of null values.</p> required <code>total</code> <code>int</code> <p>The total number of values.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp import create_temporal_null_table_row\n&gt;&gt;&gt; row = create_temporal_null_table_row(label=\"col\", num_nulls=5, total=42)\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col","title":"flamme.section.null_temp_col","text":"<p>Contain the implementation of sections to analyze the number null values for each column.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section import ColumnTemporalNullValueSection\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; section = ColumnTemporalNullValueSection(\n...     frame=frame, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; section\nColumnTemporalNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.columns","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.dt_column","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.figsize","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.frame","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.ncols","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.ncols  <code>property</code>","text":"<pre><code>ncols: int\n</code></pre> <p>The number of columns to show the figures.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.ColumnTemporalNullValueSection.period","title":"flamme.section.null_temp_col.ColumnTemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.null_temp_col.add_column_to_figure","title":"flamme.section.null_temp_col.add_column_to_figure","text":"<pre><code>add_column_to_figure(\n    columns: Sequence[str], figures: Sequence[str]\n) -&gt; list[str]\n</code></pre> <p>Add the column name to the HTML representation of the figure.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>figures</code> <code>Sequence[str]</code> <p>The HTML representations of each figure.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The uplated HTML representations of each figure.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the number of column names is different from the number of figures.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp_col import add_column_to_figure\n&gt;&gt;&gt; figures = add_column_to_figure(columns=[\"col1\", \"col2\"], figures=[\"fig1\", \"fig2\"])\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_section_template","title":"flamme.section.null_temp_col.create_section_template","text":"<pre><code>create_section_template() -&gt; str\n</code></pre> <p>Return the template of the section.</p> <p>Returns:</p> Type Description <code>str</code> <p>The section template.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp_col import create_section_template\n&gt;&gt;&gt; template = create_section_template()\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_table_section","title":"flamme.section.null_temp_col.create_table_section","text":"<pre><code>create_table_section(\n    frame: DataFrame,\n    columns: Sequence[str],\n    dt_column: str,\n    period: str,\n) -&gt; str\n</code></pre> <p>Return a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp_col import create_table_section\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; table = create_table_section(\n...     frame=frame, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_temporal_null_figure","title":"flamme.section.null_temp_col.create_temporal_null_figure","text":"<pre><code>create_temporal_null_figure(\n    frame: DataFrame,\n    columns: Sequence[str],\n    dt_column: str,\n    period: str,\n    ncols: int = 2,\n    figsize: tuple[float, float] = (7, 5),\n) -&gt; str\n</code></pre> <p>Create a HTML representation of a figure with the temporal null value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the figure.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp_col import create_temporal_null_figure\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; figures = create_temporal_null_figure(\n...     frame=frame, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_temporal_null_figures","title":"flamme.section.null_temp_col.create_temporal_null_figures","text":"<pre><code>create_temporal_null_figures(\n    frame: DataFrame,\n    columns: Sequence[str],\n    dt_column: str,\n    period: str,\n    figsize: tuple[float, float] = (7, 5),\n) -&gt; list[str]\n</code></pre> <p>Create a HTML representation of each figure with the temporal null value distribution.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The HTML representations of the figures.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp_col import create_temporal_null_figures\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; figures = create_temporal_null_figures(\n...     frame=frame, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_temporal_null_table","title":"flamme.section.null_temp_col.create_temporal_null_table","text":"<pre><code>create_temporal_null_table(\n    frame: DataFrame,\n    column: str,\n    dt_column: str,\n    period: str,\n) -&gt; str\n</code></pre> <p>Return a HTML representation of a table with the temporal distribution of null values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML representation of the table.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from flamme.section.null_temp_col import create_temporal_null_table\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...         \"datetime\": [\n...             datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...             datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...         ],\n...     },\n...     schema={\n...         \"int\": pl.Int64,\n...         \"float\": pl.Float64,\n...         \"str\": pl.String,\n...         \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...     },\n... )\n&gt;&gt;&gt; table = create_temporal_null_table(\n...     frame=frame, column=\"int\", dt_column=\"datetime\", period=\"1mo\"\n... )\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.create_temporal_null_table_row","title":"flamme.section.null_temp_col.create_temporal_null_table_row","text":"<pre><code>create_temporal_null_table_row(\n    label: str, null: int, total: int\n) -&gt; str\n</code></pre> <p>Return the HTML code of a new table row.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The label of the row.</p> required <code>null</code> <code>int</code> <p>The number of null values.</p> required <code>total</code> <code>int</code> <p>The total number of values.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The HTML code of a row.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp_col import create_temporal_null_table_row\n&gt;&gt;&gt; row = create_temporal_null_table_row(label=\"col\", null=5, total=42)\n</code></pre>"},{"location":"refs/section/#flamme.section.null_temp_col.split_figures_by_column","title":"flamme.section.null_temp_col.split_figures_by_column","text":"<pre><code>split_figures_by_column(\n    figures: Sequence[str], ncols: int\n) -&gt; list[str]\n</code></pre> <p>Split the figures into multiple columns.</p> <p>Parameters:</p> Name Type Description Default <code>figures</code> <code>Sequence[str]</code> <p>The HTML representations of each figure.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section.null_temp_col import split_figures_by_column\n&gt;&gt;&gt; cols = split_figures_by_column(figures=[\"fig1\", \"fig2\", \"fig3\"], ncols=2)\n</code></pre>"},{"location":"refs/section/#flamme.section.toc","title":"flamme.section.toc","text":"<p>Implement a section that generates a table of content.</p>"},{"location":"refs/section/#flamme.section.toc.TableOfContentSection","title":"flamme.section.toc.TableOfContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a wrapper section that generates a table of content before the section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseSection</code> <p>The section.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import TableOfContentSection, DuplicatedRowSection\n&gt;&gt;&gt; section = TableOfContentSection(\n...     DuplicatedRowSection(\n...         frame=pl.DataFrame(\n...             {\n...                 \"col1\": [1.2, 4.2, 4.2, 2.2],\n...                 \"col2\": [1, 1, 1, 1],\n...                 \"col3\": [1, 2, 2, 2],\n...             },\n...             schema={\"col1\": pl.Float64, \"col2\": pl.Int64, \"col3\": pl.Int64},\n...         )\n...     )\n... )\n&gt;&gt;&gt; section\nTableOfContentSection(\n  (section): DuplicatedRowSection(\n      (frame): (4, 3)\n      (columns): None\n      (figsize): None\n    )\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.utils","title":"flamme.section.utils","text":"<p>Contain utility functions to generate sections.</p>"},{"location":"refs/section/#flamme.section.utils.render_html_toc","title":"flamme.section.utils.render_html_toc","text":"<pre><code>render_html_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p>"},{"location":"refs/section/#flamme.section.utils.tags2id","title":"flamme.section.utils.tags2id","text":"<pre><code>tags2id(tags: Sequence[str]) -&gt; str\n</code></pre> <p>Convert a sequence of tags to a string that can be used as ID in a HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Sequence[str]</code> <p>The sequence of tags.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated ID from the tags.</p>"},{"location":"refs/section/#flamme.section.utils.tags2title","title":"flamme.section.utils.tags2title","text":"<pre><code>tags2title(tags: Sequence[str]) -&gt; str\n</code></pre> <p>Convert a sequence of tags to a string that can be used as title.</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Sequence[str]</code> <p>The sequence of tags.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated title from the tags.</p>"},{"location":"refs/section/#flamme.section.utils.valid_h_tag","title":"flamme.section.utils.valid_h_tag","text":"<pre><code>valid_h_tag(index: int) -&gt; int\n</code></pre> <p>Return a valid number of a h HTML tag.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The original value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>A valid value.</p>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#flamme.utils","title":"flamme.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#flamme.utils.setup_object","title":"flamme.utils.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.utils import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"}]}