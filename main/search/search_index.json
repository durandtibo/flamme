{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>A library to generate custom reports of pandas DataFrames.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>flamme</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>flamme</code> to a new version will possibly break any code that was using the old version of <code>flamme</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>flamme</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install flamme\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>flamme</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'flamme[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>flamme</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/flamme.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate flamme\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>flamme</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/analyzer/","title":"analyzer","text":""},{"location":"refs/analyzer/#flamme.analyzer","title":"flamme.analyzer","text":"<p>Contain DataFrame analyzers.</p>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer","title":"flamme.analyzer.BaseAnalyzer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to analyze a DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.BaseAnalyzer.analyze","title":"flamme.analyzer.BaseAnalyzer.analyze","text":"<pre><code>analyze(frame: DataFrame) -&gt; BaseSection\n</code></pre> <p>Analyze the data in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame with the data to analyze.</p> required <p>Returns:</p> Type Description <code>BaseSection</code> <p>The section report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ChoiceAnalyzer","title":"flamme.analyzer.ChoiceAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>selection_fn</code> <code>Callable[[DataFrame], str]</code> <p>Specifies a callable with the selection logic. The callable returns the key of the analyzer to use based on the data in the input DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import (\n...     ChoiceAnalyzer,\n...     FilteredAnalyzer,\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = ChoiceAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()},\n...     selection_fn=lambda frame: \"null\" if frame.isna().values.any() else \"duplicate\",\n... )\n&gt;&gt;&gt; analyzer\nChoiceAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section.__class__.__qualname__\nNullValueSection\n&gt;&gt;&gt; frame = pd.DataFrame({\"col\": np.arange(10)})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n&gt;&gt;&gt; section.__class__.__qualname__\nDuplicatedRowSection\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAdvancedAnalyzer","title":"flamme.analyzer.ColumnContinuousAdvancedAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAdvancedAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAdvancedAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAdvancedAnalyzer(column=float, nbins=None, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnContinuousAnalyzer","title":"flamme.analyzer.ColumnContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q0'</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>'q1'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnContinuousAnalyzer\n&gt;&gt;&gt; analyzer = ColumnContinuousAnalyzer(column=\"float\")\n&gt;&gt;&gt; analyzer\nColumnContinuousAnalyzer(column=float, nbins=None, yscale=auto, xmin=q0, xmax=q1, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnDiscreteAnalyzer","title":"flamme.analyzer.ColumnDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a discrete distribution analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dropna</code> <code>bool</code> <p>If <code>True</code>, the NaN values are not included in the analysis.</p> <code>False</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnDiscreteAnalyzer(column=\"str\")\n&gt;&gt;&gt; analyzer\nColumnDiscreteAnalyzer(column=str, dropna=False, max_rows=20, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnSubsetAnalyzer","title":"flamme.analyzer.ColumnSubsetAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to analyze only a subset of the columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>Soecifies the columns to select.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnSubsetAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnSubsetAnalyzer(columns=[\"int\", \"float\"], analyzer=NullValueAnalyzer())\n&gt;&gt;&gt; analyzer\nColumnSubsetAnalyzer(\n  (columns): 2 ['int', 'float']\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalContinuousAnalyzer","title":"flamme.analyzer.ColumnTemporalContinuousAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalContinuousAnalyzer(\n...     column=\"float\", dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalContinuousAnalyzer(column=float, dt_column=datetime, period=M, yscale=auto, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalDiscreteAnalyzer","title":"flamme.analyzer.ColumnTemporalDiscreteAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalDiscreteAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalDiscreteAnalyzer(\n...     column=\"str\", dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; analyzer\nColumnTemporalDiscreteAnalyzer(column=str, dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ColumnTemporalNullValueAnalyzer","title":"flamme.analyzer.ColumnTemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>A plot is generated for each column.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The list of columns to analyze. A plot is generated for each column. <code>None</code> means all the columns.</p> <code>None</code> <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ColumnTemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = ColumnTemporalNullValueAnalyzer(\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nColumnTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.ContentAnalyzer","title":"flamme.analyzer.ContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import ContentAnalyzer\n&gt;&gt;&gt; analyzer = ContentAnalyzer(content=\"meow\")\n&gt;&gt;&gt; analyzer\nContentAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataFrameSummaryAnalyzer","title":"flamme.analyzer.DataFrameSummaryAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show a summary of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <code>sort</code> <code>bool</code> <p>If <code>True</code>, sort the columns by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import DataFrameSummaryAnalyzer\n&gt;&gt;&gt; analyzer = DataFrameSummaryAnalyzer()\n&gt;&gt;&gt; analyzer\nDataFrameSummaryAnalyzer(top=5, sort=False)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col1\": np.array([0, 1, 0, 1]),\n...         \"col2\": np.array([1, 0, 1, 0]),\n...         \"col3\": np.array([1, 1, 1, 1]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DataTypeAnalyzer","title":"flamme.analyzer.DataTypeAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to find all the value types in each column.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import DataTypeAnalyzer\n&gt;&gt;&gt; analyzer = DataTypeAnalyzer()\n&gt;&gt;&gt; analyzer\nDataTypeAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.DuplicatedRowAnalyzer","title":"flamme.analyzer.DuplicatedRowAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = DuplicatedRowAnalyzer()\n&gt;&gt;&gt; analyzer\nDuplicatedRowAnalyzer(columns=None, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col1\": np.array([0, 1, 0, 1]),\n...         \"col2\": np.array([1, 0, 1, 0]),\n...         \"col3\": np.array([1, 1, 1, 1]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.FilteredAnalyzer","title":"flamme.analyzer.FilteredAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that filters the data before to analyze the data.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Soecifies the query.</p> required <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import FilteredAnalyzer, NullValueAnalyzer\n&gt;&gt;&gt; analyzer = FilteredAnalyzer(query=\"float &gt;= 2.0\", analyzer=NullValueAnalyzer())\n&gt;&gt;&gt; analyzer\nFilteredAnalyzer(\n  (query): float &gt;= 2.0\n  (analyzer): NullValueAnalyzer(figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer","title":"flamme.analyzer.MappingAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that combine multiple analyzers.</p> <p>Parameters:</p> Name Type Description Default <code>analyzers</code> <code>Mapping[str, BaseAnalyzer | dict]</code> <p>The mappings to analyze. The key of each analyzer is used to organize the metrics and report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import (\n...     FilteredAnalyzer,\n...     NullValueAnalyzer,\n...     DuplicatedRowAnalyzer,\n...     MappingAnalyzer,\n... )\n&gt;&gt;&gt; analyzer = MappingAnalyzer(\n...     {\"null\": NullValueAnalyzer(), \"duplicate\": DuplicatedRowAnalyzer()}\n... )\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MappingAnalyzer.add_analyzer","title":"flamme.analyzer.MappingAnalyzer.add_analyzer","text":"<pre><code>add_analyzer(\n    key: str,\n    analyzer: BaseAnalyzer,\n    replace_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Add an analyzer to the current analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the analyzer.</p> required <code>analyzer</code> <code>BaseAnalyzer</code> <p>The analyzer to add.</p> required <code>replace_ok</code> <code>bool</code> <p>If <code>False</code>, <code>KeyError</code> is raised if an analyzer with the same key exists. If <code>True</code>, the new analyzer will replace the existing analyzer.</p> <code>False</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if an  analyzer with the same key exists.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import MappingAnalyzer, NullValueAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = MappingAnalyzer({\"null\": NullValueAnalyzer()})\n&gt;&gt;&gt; analyzer.add_analyzer(\"duplicate\", DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nMappingAnalyzer(\n  (null): NullValueAnalyzer(figsize=None)\n  (duplicate): DuplicatedRowAnalyzer(columns=None, figsize=None)\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MarkdownAnalyzer","title":"flamme.analyzer.MarkdownAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer that adds a mardown string to the report.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown description.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import MarkdownAnalyzer\n&gt;&gt;&gt; analyzer = MarkdownAnalyzer(desc=\"hello cats!\")\n&gt;&gt;&gt; analyzer\nMarkdownAnalyzer()\n&gt;&gt;&gt; frame = pd.DataFrame({})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.MostFrequentValuesAnalyzer","title":"flamme.analyzer.MostFrequentValuesAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a most frequent values analyzer for a given column.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dropna</code> <code>bool</code> <p>If <code>True</code>, the NaN values are not included in the analysis.</p> <code>False</code> <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import MostFrequentValuesAnalyzer\n&gt;&gt;&gt; analyzer = MostFrequentValuesAnalyzer(column=\"str\")\n&gt;&gt;&gt; analyzer\nMostFrequentValuesAnalyzer(column=str, dropna=False, top=100)\n&gt;&gt;&gt; frame = pd.DataFrame({\"col\": np.array([np.nan, 1, 0, 1])})\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.NullValueAnalyzer","title":"flamme.analyzer.NullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a null value analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; analyzer = NullValueAnalyzer()\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TableOfContentAnalyzer","title":"flamme.analyzer.TableOfContentAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement a wrapper around an analyzer to add a table of content to the generated section report.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>The analyzer or its configuration.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TableOfContentAnalyzer, DuplicatedRowAnalyzer\n&gt;&gt;&gt; analyzer = TableOfContentAnalyzer(DuplicatedRowAnalyzer())\n&gt;&gt;&gt; analyzer\nTableOfContentAnalyzer(\n  (analyzer): DuplicatedRowAnalyzer(columns=None, figsize=None)\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col1\": np.array([0, 1, 0, 1]),\n...         \"col2\": np.array([1, 0, 1, 0]),\n...         \"col3\": np.array([1, 1, 1, 1]),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalNullValueAnalyzer","title":"flamme.analyzer.TemporalNullValueAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TemporalNullValueAnalyzer\n&gt;&gt;&gt; analyzer = TemporalNullValueAnalyzer(dt_column=\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nTemporalNullValueAnalyzer(\n  (columns): None\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"col\": np.array([np.nan, 1, 0, 1]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.TemporalRowCountAnalyzer","title":"flamme.analyzer.TemporalRowCountAnalyzer","text":"<p>               Bases: <code>BaseAnalyzer</code></p> <p>Implement an analyzer to show the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.analyzer import TemporalRowCountAnalyzer\n&gt;&gt;&gt; analyzer = TemporalRowCountAnalyzer(dt_column=\"datetime\", period=\"M\")\n&gt;&gt;&gt; analyzer\nTemporalRowCountAnalyzer(dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = analyzer.analyze(frame)\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.is_analyzer_config","title":"flamme.analyzer.is_analyzer_config","text":"<pre><code>is_analyzer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseAnalyzer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseAnalyzer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import is_analyzer_config\n&gt;&gt;&gt; is_analyzer_config({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\nTrue\n</code></pre>"},{"location":"refs/analyzer/#flamme.analyzer.setup_analyzer","title":"flamme.analyzer.setup_analyzer","text":"<pre><code>setup_analyzer(\n    analyzer: BaseAnalyzer | dict,\n) -&gt; BaseAnalyzer\n</code></pre> <p>Set up an analyzer.</p> <p>The analyzer is instantiated from its configuration by using the <code>BaseAnalyzer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>analyzer</code> <code>BaseAnalyzer | dict</code> <p>Specifies an analyzer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseAnalyzer</code> <p>An instantiated analyzer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import setup_analyzer\n&gt;&gt;&gt; analyzer = setup_analyzer({\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"})\n&gt;&gt;&gt; analyzer\nNullValueAnalyzer(figsize=None)\n</code></pre>"},{"location":"refs/ingestor/","title":"ingestor","text":""},{"location":"refs/ingestor/#flamme.ingestor","title":"flamme.ingestor","text":"<p>Contain data ingestors.</p>"},{"location":"refs/ingestor/#flamme.ingestor.BaseIngestor","title":"flamme.ingestor.BaseIngestor","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a DataFrame ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.BaseIngestor.ingest","title":"flamme.ingestor.BaseIngestor.ingest","text":"<pre><code>ingest() -&gt; DataFrame\n</code></pre> <p>Ingest a DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The ingested DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.ClickHouseIngestor","title":"flamme.ingestor.ClickHouseIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a clickhouse DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The clickhouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import ClickHouseIngestor\n&gt;&gt;&gt; import clickhouse_connect\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; ingestor = ClickHouseIngestor(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.CsvIngestor","title":"flamme.ingestor.CsvIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a CSV DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the CSV file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>pandas.read_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(path=/path/to/frame.csv)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.Ingestor","title":"flamme.ingestor.Ingestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor(\n...     frame=pd.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor\nIngestor(shape=(5, 4))\n&gt;&gt;&gt; frame = ingestor.ingest()\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.ParquetIngestor","title":"flamme.ingestor.ParquetIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a parquet DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>pandas.read_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.TransformedIngestor","title":"flamme.ingestor.TransformedIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that also transforms the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The base ingestor.</p> required <code>transformer</code> <code>BaseDataFrameTransformer | dict</code> <p>Specifies a <code>pandas.DataFrame</code> transformer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import TransformedIngestor, ParquetIngestor\n&gt;&gt;&gt; from flamme.transformer.dataframe import ToNumeric\n&gt;&gt;&gt; ingestor = TransformedIngestor(\n...     ingestor=ParquetIngestor(path=\"/path/to/frame.csv\"),\n...     transformer=ToNumeric(columns=[\"col1\", \"col3\"]),\n... )\n&gt;&gt;&gt; ingestor\nTransformedIngestor(\n  (ingestor): ParquetIngestor(path=/path/to/frame.csv)\n  (transformer): ToNumericDataFrameTransformer(columns=('col1', 'col3'))\n)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.is_ingestor_config","title":"flamme.ingestor.is_ingestor_config","text":"<pre><code>is_ingestor_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseIngestor</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseIngestor</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import is_ingestor_config\n&gt;&gt;&gt; is_ingestor_config(\n...     {\"_target_\": \"flamme.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/ingestor/#flamme.ingestor.setup_ingestor","title":"flamme.ingestor.setup_ingestor","text":"<pre><code>setup_ingestor(\n    ingestor: BaseIngestor | dict,\n) -&gt; BaseIngestor\n</code></pre> <p>Set up an ingestor.</p> <p>The ingestor is instantiated from its configuration by using the <code>BaseIngestor</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>Specifies an ingestor or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseIngestor</code> <p>An instantiated ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.ingestor import setup_ingestor\n&gt;&gt;&gt; ingestor = setup_ingestor(\n...     {\"_target_\": \"flamme.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\n&gt;&gt;&gt; ingestor\nCsvIngestor(path=/path/to/data.csv)\n</code></pre>"},{"location":"refs/reporter/","title":"reporter","text":""},{"location":"refs/reporter/#flamme.reporter","title":"flamme.reporter","text":"<p>Contain reporters.</p>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter","title":"flamme.reporter.BaseReporter","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to compute a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; from flamme.transformer.dataframe import SequentialDataFrameTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialDataFrameTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): ParquetIngestor(path=/path/to/data.parquet)\n  (transformer): SequentialDataFrameTransformer()\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.BaseReporter.compute","title":"flamme.reporter.BaseReporter.compute","text":"<pre><code>compute() -&gt; None\n</code></pre> <p>Generate a HTML report.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; from flamme.transformer.dataframe import SequentialDataFrameTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialDataFrameTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(figsize=None),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.NoRepeatReporter","title":"flamme.reporter.NoRepeatReporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a reporter that computes the report only once.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>The reporter or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; from flamme.transformer.dataframe import SequentialDataFrameTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter, NoRepeatReporter\n&gt;&gt;&gt; reporter = NoRepeatReporter(\n...     reporter=Reporter(\n...         ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...         transformer=SequentialDataFrameTransformer(transformers=[]),\n...         analyzer=NullValueAnalyzer(),\n...         report_path=\"/path/to/report.html\",\n...     ),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.Reporter","title":"flamme.reporter.Reporter","text":"<p>               Bases: <code>BaseReporter</code></p> <p>Implement a simple reporter.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The ingestor or its configuration.</p> required <code>transformer</code> <code>BaseDataFrameTransformer | dict</code> <p>Specifies a <code>pandas.DataFrame</code> transformer or its configuration.</p> required <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The analyzer or its configuration.</p> required <code>report_path</code> <code>Path | str</code> <p>The path where to save the HTML report.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>6</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.analyzer import NullValueAnalyzer\n&gt;&gt;&gt; from flamme.ingestor import ParquetIngestor\n&gt;&gt;&gt; from flamme.transformer.dataframe import SequentialDataFrameTransformer\n&gt;&gt;&gt; from flamme.reporter import Reporter\n&gt;&gt;&gt; reporter = Reporter(\n...     ingestor=ParquetIngestor(\"/path/to/data.parquet\"),\n...     transformer=SequentialDataFrameTransformer(transformers=[]),\n...     analyzer=NullValueAnalyzer(),\n...     report_path=\"/path/to/report.html\",\n... )\n&gt;&gt;&gt; report = reporter.compute()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.is_reporter_config","title":"flamme.reporter.is_reporter_config","text":"<pre><code>is_reporter_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseReporter</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseReporter</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import is_reporter_config\n&gt;&gt;&gt; is_reporter_config(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"flamme.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\n...             \"_target_\": \"flamme.transformer.dataframe.ToNumeric\",\n...             \"columns\": [\"col1\", \"col3\"],\n...         },\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/reporter/#flamme.reporter.setup_reporter","title":"flamme.reporter.setup_reporter","text":"<pre><code>setup_reporter(\n    reporter: BaseReporter | dict,\n) -&gt; BaseReporter\n</code></pre> <p>Set up a reporter.</p> <p>The reporter is instantiated from its configuration by using the <code>BaseReporter</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reporter</code> <code>BaseReporter | dict</code> <p>Specifies an reporter or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseReporter</code> <p>An instantiated reporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.reporter import setup_reporter\n&gt;&gt;&gt; reporter = setup_reporter(\n...     {\n...         \"_target_\": \"flamme.reporter.Reporter\",\n...         \"ingestor\": {\n...             \"_target_\": \"flamme.ingestor.CsvIngestor\",\n...             \"path\": \"/path/to/data.csv\",\n...         },\n...         \"transformer\": {\n...             \"_target_\": \"flamme.transformer.dataframe.ToNumeric\",\n...             \"columns\": [\"col1\", \"col3\"],\n...         },\n...         \"analyzer\": {\"_target_\": \"flamme.analyzer.NullValueAnalyzer\"},\n...         \"report_path\": \"/path/to/report.html\",\n...     }\n... )\n&gt;&gt;&gt; reporter\nReporter(\n  (ingestor): CsvIngestor(path=/path/to/data.csv)\n  (transformer): ToNumericDataFrameTransformer(columns=('col1', 'col3'))\n  (analyzer): NullValueAnalyzer(figsize=None)\n  (report_path): /path/to/report.html\n  (max_toc_depth): 6\n)\n</code></pre>"},{"location":"refs/schema/","title":"schema","text":""},{"location":"refs/schema/#flamme.schema","title":"flamme.schema","text":"<p>Contain functionalities to manipulate DataFrame's schemas.</p>"},{"location":"refs/schema/#flamme.schema.reader","title":"flamme.schema.reader","text":"<p>Contain schema readers.</p>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader","title":"flamme.schema.reader.BaseSchemaReader","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(\n...         path, index=False\n...     )\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.BaseSchemaReader.read","title":"flamme.schema.reader.BaseSchemaReader.read","text":"<pre><code>read() -&gt; Schema\n</code></pre> <p>Read the schema associated to a DataFrame.</p> <p>Returns:</p> Type Description <code>Schema</code> <p>The ingested DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(path, index=False)\n...     reader = ParquetSchemaReader(path)\n...     schema = reader.read()\n...     schema\n...\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ClickHouseSchemaReader","title":"flamme.schema.reader.ClickHouseSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The clickhouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.schema.reader import ClickHouseSchemaReader\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; reader = ClickHouseSchemaReader(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; schema = reader.read()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.ParquetSchemaReader","title":"flamme.schema.reader.ParquetSchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a parquet schema reader.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from flamme.schema.reader import ParquetSchemaReader\n&gt;&gt;&gt; with tempfile.TemporaryDirectory() as tmpdir:\n...     path = Path(tmpdir).joinpath(\"data.parquet\")\n...     pd.DataFrame({\"col1\": [1, 2, 3], \"col2\": [\"a\", \"b\", \"c\"]}).to_parquet(\n...         path, index=False\n...     )\n...     reader = ParquetSchemaReader(path)\n...     reader\n...     schema = reader.read()\n...     schema\n...\nParquetSchemaReader(path=.../data.parquet)\ncol1: int64\ncol2: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.SchemaReader","title":"flamme.schema.reader.SchemaReader","text":"<p>               Bases: <code>BaseSchemaReader</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.schema.reader import SchemaReader\n&gt;&gt;&gt; reader = SchemaReader(\n...     frame=pd.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [1.1, 2.2, 3.3, 4.4, 5.5],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; reader\nSchemaReader(shape=(5, 3))\n&gt;&gt;&gt; schema = reader.read()\n&gt;&gt;&gt; schema\ncol1: int64\ncol2: double\ncol4: string\n...\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.is_schema_reader_config","title":"flamme.schema.reader.is_schema_reader_config","text":"<pre><code>is_schema_reader_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseSchemaReader</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseSchemaReader</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import is_schema_reader_config\n&gt;&gt;&gt; is_schema_reader_config(\n...     {\"_target_\": \"flamme.schema.reader.ParquetSchemaReader\", \"path\": \"/path/to/data.parquet\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/schema/#flamme.schema.reader.setup_schema_reader","title":"flamme.schema.reader.setup_schema_reader","text":"<pre><code>setup_schema_reader(\n    reader: BaseSchemaReader | dict,\n) -&gt; BaseSchemaReader\n</code></pre> <p>Set up a schema reader.</p> <p>The reader is instantiated from its configuration by using the <code>BaseSchemaReader</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>reader</code> <code>BaseSchemaReader | dict</code> <p>Specifies a schema reader or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseSchemaReader</code> <p>An instantiated schema reader.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.schema.reader import setup_schema_reader\n&gt;&gt;&gt; reader = setup_schema_reader(\n...     {\"_target_\": \"flamme.schema.reader.ParquetSchemaReader\", \"path\": \"/path/to/data.parquet\"}\n... )\n&gt;&gt;&gt; reader\nParquetSchemaReader(path=.../data.parquet)\n</code></pre>"},{"location":"refs/section/","title":"section","text":""},{"location":"refs/section/#flamme.section","title":"flamme.section","text":"<p>Contain sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection","title":"flamme.section.BaseSection","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to manage sections.</p>"},{"location":"refs/section/#flamme.section.BaseSection.get_statistics","title":"flamme.section.BaseSection.get_statistics  <code>abstractmethod</code>","text":"<pre><code>get_statistics() -&gt; dict\n</code></pre> <p>Return the statistics associated to the section.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The statistics.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_body","title":"flamme.section.BaseSection.render_html_body  <code>abstractmethod</code>","text":"<pre><code>render_html_body(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n) -&gt; str\n</code></pre> <p>Return the HTML body associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML body associated to the section.</p>"},{"location":"refs/section/#flamme.section.BaseSection.render_html_toc","title":"flamme.section.BaseSection.render_html_toc  <code>abstractmethod</code>","text":"<pre><code>render_html_toc(\n    number: str = \"\",\n    tags: Sequence[str] = (),\n    depth: int = 0,\n    max_depth: int = 1,\n) -&gt; str\n</code></pre> <p>Return the HTML table of content (TOC) associated to the section.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>The section number associated to the section.</p> <code>''</code> <code>tags</code> <code>Sequence[str]</code> <p>The tags associated to the section.</p> <code>()</code> <code>depth</code> <code>int</code> <p>The depth in the report.</p> <code>0</code> <code>max_depth</code> <code>int</code> <p>The maximum depth to generate in the TOC.</p> <code>1</code> <p>Returns:</p> Type Description <code>str</code> <p>The HTML table of content associated to the section.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection","title":"flamme.section.ColumnContinuousAdvancedSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousAdvancedSection(\n...     series=pd.Series([np.nan, *list(range(101)), np.nan]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousAdvancedSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'num_nulls': 2, 'nunique': 102, 'mean': 50.0, 'std': 29.30...,\n 'skewness': 0.0, 'kurtosis': -1.200235294117647, 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1, 'num_non_nulls': 101}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousAdvancedSection.figsize","title":"flamme.section.ColumnContinuousAdvancedSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection","title":"flamme.section.ColumnContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a continuous distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series/column to analyze.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>nbins</code> <code>int | None</code> <p>The number of bins in the histogram.</p> <code>None</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>xmin</code> <code>float | str | None</code> <p>The minimum value of the range or its associated quantile. <code>q0.1</code> means the 10% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>xmax</code> <code>float | str | None</code> <p>The maximum value of the range or its associated quantile. <code>q0.9</code> means the 90% quantile. <code>0</code> is the minimum value and <code>1</code> is the maximum value.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnContinuousSection(\n...     series=pd.Series([np.nan, *list(range(101)), np.nan]), column=\"col\"\n... )\n&gt;&gt;&gt; section\nColumnContinuousSection(\n  (column): col\n  (nbins): None\n  (yscale): auto\n  (xmin): None\n  (xmax): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'count': 103, 'num_nulls': 2, 'nunique': 102, 'mean': 50.0, 'std': 29.30...,\n 'skewness': 0.0, 'kurtosis': -1.200235294117647, 'min': 0.0,\n 'q001': 0.1, 'q01': 1.0, 'q05': 5.0, 'q10': 10.0, 'q25': 25.0, 'median': 50.0,\n 'q75': 75.0, 'q90': 90.0, 'q95': 95.0, 'q99': 99.0, 'q999': 99.9, 'max': 100.0,\n '&gt;0': 100, '&lt;0': 0, '=0': 1, 'num_non_nulls': 101}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnContinuousSection.figsize","title":"flamme.section.ColumnContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection","title":"flamme.section.ColumnDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes a discrete distribution of values.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter that represents the discrete distribution.</p> required <code>null_values</code> <code>int</code> <p>The number of null values.</p> <code>0</code> <code>column</code> <code>str</code> <p>The column name.</p> <code>'N/A'</code> <code>max_rows</code> <code>int</code> <p>The maximum number of rows to show in the table.</p> <code>20</code> <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import ColumnDiscreteSection\n&gt;&gt;&gt; section = ColumnDiscreteSection(counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\")\n&gt;&gt;&gt; section\nColumnDiscreteSection(\n  (null_values): 0\n  (column): col\n  (yscale): auto\n  (max_rows): 20\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)], 'nunique': 3, 'total': 12}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnDiscreteSection.figsize","title":"flamme.section.ColumnDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection","title":"flamme.section.ColumnTemporalContinuousSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>yscale</code> <code>str</code> <p>The y-axis scale. If <code>'auto'</code>, the <code>'linear'</code> or <code>'log'/'symlog'</code> scale is chosen based on the distribution.</p> <code>'auto'</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import ColumnContinuousSection\n&gt;&gt;&gt; section = ColumnTemporalContinuousSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col\": np.array([1.2, 4.2, np.nan, 2.2]),\n...             \"datetime\": pd.to_datetime(\n...                 [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...             ),\n...         }\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalContinuousSection(\n  (column): col\n  (dt_column): datetime\n  (period): M\n  (yscale): auto\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalContinuousSection.figsize","title":"flamme.section.ColumnTemporalContinuousSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection","title":"flamme.section.ColumnTemporalDiscreteSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the temporal distribution of a column with discrete values.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column of the DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import ColumnTemporalDiscreteSection\n&gt;&gt;&gt; section = ColumnTemporalDiscreteSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col\": np.array([1, 42, np.nan, 22]),\n...             \"col2\": [\"a\", \"b\", 1, \"a\"],\n...             \"datetime\": pd.to_datetime(\n...                 [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...             ),\n...         }\n...     ),\n...     column=\"col\",\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nColumnTemporalDiscreteSection(\n  (column): col\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalDiscreteSection.figsize","title":"flamme.section.ColumnTemporalDiscreteSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection","title":"flamme.section.ColumnTemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze. A plot is generated for each column.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>ncols</code> <code>int</code> <p>The number of columns.</p> <code>2</code> <code>figsize</code> <code>tuple[float, float]</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>(7, 5)</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import ColumnTemporalNullValueSection\n&gt;&gt;&gt; dataframe = pd.DataFrame(\n...     {\n...         \"float\": np.array([1.2, 4.2, np.nan, 2.2]),\n...         \"int\": np.array([np.nan, 1, 0, 1]),\n...         \"str\": np.array([\"A\", \"B\", None, np.nan]),\n...         \"datetime\": pd.to_datetime(\n...             [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...         ),\n...     }\n... )\n&gt;&gt;&gt; section = ColumnTemporalNullValueSection(\n...     frame=dataframe, columns=[\"float\", \"int\", \"str\"], dt_column=\"datetime\", period=\"M\"\n... )\n&gt;&gt;&gt; section\nColumnTemporalNullValueSection(\n  (columns): ('float', 'int', 'str')\n  (dt_column): datetime\n  (period): M\n  (ncols): 2\n  (figsize): (7, 5)\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.columns","title":"flamme.section.ColumnTemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.dt_column","title":"flamme.section.ColumnTemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.figsize","title":"flamme.section.ColumnTemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.frame","title":"flamme.section.ColumnTemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.ncols","title":"flamme.section.ColumnTemporalNullValueSection.ncols  <code>property</code>","text":"<pre><code>ncols: int\n</code></pre> <p>The number of columns to show the figures.</p>"},{"location":"refs/section/#flamme.section.ColumnTemporalNullValueSection.period","title":"flamme.section.ColumnTemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.ContentSection","title":"flamme.section.ContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that generates the given custom content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to use in the HTML code.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import ContentSection\n&gt;&gt;&gt; section = ContentSection(content=\"meow\")\n&gt;&gt;&gt; section\nContentSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.DataFrameSummarySection","title":"flamme.section.DataFrameSummarySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that returns a summary of a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>top</code> <code>int</code> <p>The number of most frequent values to show.</p> <code>5</code> <p>Example usage:</p> <p>```pycon</p> <p>import pandas as pd import numpy as np from flamme.section import DataFrameSummarySection section = DataFrameSummarySection( ...     frame=pd.DataFrame( ...         { ...             \"col1\": np.array([1.2, 4.2, 4.2, 2.2]), ...             \"col2\": np.array([1, 1, 1, 1]), ...             \"col3\": np.array([1, 2, 2, 2]), ...         } ...     ) ... ) section DataFrameSummarySection(top=5) section.get_statistics() {'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 0, 0), 'nunique': (3, 1, 2), 'column_types': ({}, {}, {})}"},{"location":"refs/section/#flamme.section.DataFrameSummarySection.frame","title":"flamme.section.DataFrameSummarySection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.DataTypeSection","title":"flamme.section.DataTypeSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the data type of each column.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>dict[str, DTypeLike]</code> <p>The data type for each column.</p> required <code>types</code> <code>dict[str, set]</code> <p>The types of the values in each column. A column can contain multiple types. The keys are the column names.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import DataTypeSection\n&gt;&gt;&gt; section = DataTypeSection(\n...     dtypes={\n...         \"float\": np.dtype(\"float64\"),\n...         \"int\": np.dtype(\"float64\"),\n...         \"str\": np.dtype(\"O\"),\n...     },\n...     types={\"float\": {float}, \"int\": {int}, \"str\": {str, type(None)}},\n... )\n&gt;&gt;&gt; section\nDataTypeSection(\n  (dtypes): {'float': dtype('float64'), 'int': dtype('float64'), 'str': dtype('O')}\n  (types): {'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n)\n&gt;&gt;&gt; section.get_statistics()\n{'float': {&lt;class 'float'&gt;}, 'int': {&lt;class 'int'&gt;}, 'str': {&lt;class 'NoneType'&gt;, &lt;class 'str'&gt;}}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection","title":"flamme.section.DuplicatedRowSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of duplicated rows.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str] | None</code> <p>The columns used to compute the duplicated rows. <code>None</code> means all the columns.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import DuplicatedRowSection\n&gt;&gt;&gt; section = DuplicatedRowSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col1\": np.array([1.2, 4.2, 4.2, 2.2]),\n...             \"col2\": np.array([1, 1, 1, 1]),\n...             \"col3\": np.array([1, 2, 2, 2]),\n...         }\n...     )\n... )\n&gt;&gt;&gt; section\nDuplicatedRowSection(\n  (columns): None\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.columns","title":"flamme.section.DuplicatedRowSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...] | None\n</code></pre> <p>Tuple or <code>None</code>: The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.figsize","title":"flamme.section.DuplicatedRowSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.DuplicatedRowSection.frame","title":"flamme.section.DuplicatedRowSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.EmptySection","title":"flamme.section.EmptySection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement an empty section.</p> <p>This section is implemented to deal with missing columns or to skip some analyses.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import EmptySection\n&gt;&gt;&gt; section = EmptySection()\n&gt;&gt;&gt; section\nEmptySection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MarkdownSection","title":"flamme.section.MarkdownSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that converts a markdown string into HTML.</p> <p>Parameters:</p> Name Type Description Default <code>desc</code> <code>str</code> <p>The markdown string to convert.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.section import MarkdownSection\n&gt;&gt;&gt; section = MarkdownSection(desc=\"meow\")\n&gt;&gt;&gt; section\nMarkdownSection()\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.MostFrequentValuesSection","title":"flamme.section.MostFrequentValuesSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the most frequent values for a given columns.</p> <p>Parameters:</p> Name Type Description Default <code>counter</code> <code>Counter</code> <p>The counter with the number of occurrences for all values.</p> required <code>column</code> <code>str</code> <p>The column name.</p> required <code>top</code> <code>int</code> <p>The maximum number of values to show.</p> <code>100</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; from flamme.section import MostFrequentValuesSection\n&gt;&gt;&gt; section = MostFrequentValuesSection(\n...     counter=Counter({\"a\": 4, \"b\": 2, \"c\": 6}), column=\"col\"\n... )\n&gt;&gt;&gt; section\nMostFrequentValuesSection(\n  (counter): Counter({'c': 6, 'a': 4, 'b': 2})\n  (column): col\n  (top): 100\n  (total): 12\n)\n&gt;&gt;&gt; section.get_statistics()\n{'most_common': [('c', 6), ('a', 4), ('b', 2)]}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection","title":"flamme.section.NullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section that analyzes the number of null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str]</code> <p>The column names.</p> required <code>null_count</code> <code>ndarray</code> <p>The number of null values for each column.</p> required <code>total_count</code> <code>ndarray</code> <p>The total number of values for each column.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import NullValueSection\n&gt;&gt;&gt; section = NullValueSection(\n...     columns=[\"col1\", \"col2\", \"col3\"],\n...     null_count=np.array([0, 1, 2]),\n...     total_count=np.array([5, 5, 5]),\n... )\n&gt;&gt;&gt; section\nNullValueSection(\n  (columns): ('col1', 'col2', 'col3')\n  (null_count): array([0, 1, 2])\n  (total_count): array([5, 5, 5])\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{'columns': ('col1', 'col2', 'col3'), 'null_count': (0, 1, 2), 'total_count': (5, 5, 5)}\n</code></pre>"},{"location":"refs/section/#flamme.section.NullValueSection.columns","title":"flamme.section.NullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns used to compute the duplicated rows.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.figsize","title":"flamme.section.NullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.null_count","title":"flamme.section.NullValueSection.null_count  <code>property</code>","text":"<pre><code>null_count: ndarray\n</code></pre> <p>The number of null values for each column.</p>"},{"location":"refs/section/#flamme.section.NullValueSection.total_count","title":"flamme.section.NullValueSection.total_count  <code>property</code>","text":"<pre><code>total_count: ndarray\n</code></pre> <p>The total number of values for each column.</p>"},{"location":"refs/section/#flamme.section.SectionDict","title":"flamme.section.SectionDict","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to manage a dictionary of sections.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>dict[str, BaseSection]</code> <p>The dictionary of sections.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content. Set this value to <code>0</code> to not show the table of content at the beginning of the section.</p> <code>0</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import SectionDict, ContentSection, TemporalRowCountSection\n&gt;&gt;&gt; frame = pd.DataFrame(\n...     {\n...         \"datetime\": pd.to_datetime(\n...             [\n...                 \"2020-01-03\",\n...                 \"2020-01-04\",\n...                 \"2020-01-05\",\n...                 \"2020-02-03\",\n...                 \"2020-03-03\",\n...                 \"2020-04-03\",\n...             ]\n...         )\n...     }\n... )\n&gt;&gt;&gt; section = SectionDict(\n...     {\n...         \"content\": ContentSection(\"meow\"),\n...         \"rows\": TemporalRowCountSection(frame, dt_column=\"datetime\", period=\"M\"),\n...     }\n... )\n&gt;&gt;&gt; section\nSectionDict(\n  (content): ContentSection()\n  (rows): TemporalRowCountSection(dt_column=datetime, period=M, figsize=None)\n)\n&gt;&gt;&gt; section.get_statistics()\n{'content': {}, 'rows': {}}\n</code></pre>"},{"location":"refs/section/#flamme.section.TableOfContentSection","title":"flamme.section.TableOfContentSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a wrapper section that generates a table of content before the section.</p> <p>Parameters:</p> Name Type Description Default <code>section</code> <code>BaseSection</code> <p>The section.</p> required <code>max_toc_depth</code> <code>int</code> <p>The maximum level to show in the table of content.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import TableOfContentSection, DuplicatedRowSection\n&gt;&gt;&gt; section = TableOfContentSection(\n...     DuplicatedRowSection(\n...         frame=pd.DataFrame(\n...             {\n...                 \"col1\": np.array([1.2, 4.2, 4.2, 2.2]),\n...                 \"col2\": np.array([1, 1, 1, 1]),\n...                 \"col3\": np.array([1, 2, 2, 2]),\n...             }\n...         )\n...     )\n... )\n&gt;&gt;&gt; section\nTableOfContentSection(\n  (section): DuplicatedRowSection(\n      (columns): None\n      (figsize): None\n    )\n  (max_toc_depth): 1\n)\n&gt;&gt;&gt; section.get_statistics()\n{'num_rows': 4, 'num_unique_rows': 3}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection","title":"flamme.section.TemporalNullValueSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the temporal distribution of null values for all columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from flamme.section import TemporalNullValueSection\n&gt;&gt;&gt; section = TemporalNullValueSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"col1\": np.array([1.2, 4.2, np.nan, 2.2]),\n...             \"col2\": np.array([np.nan, 1, np.nan, 1]),\n...             \"datetime\": pd.to_datetime(\n...                 [\"2020-01-03\", \"2020-02-03\", \"2020-03-03\", \"2020-04-03\"]\n...             ),\n...         }\n...     ),\n...     columns=[\"col1\", \"col2\"],\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nTemporalNullValueSection(\n  (columns): ('col1', 'col2')\n  (dt_column): datetime\n  (period): M\n  (figsize): None\n)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.columns","title":"flamme.section.TemporalNullValueSection.columns  <code>property</code>","text":"<pre><code>columns: tuple[str, ...]\n</code></pre> <p>The columns to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.dt_column","title":"flamme.section.TemporalNullValueSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.figsize","title":"flamme.section.TemporalNullValueSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.frame","title":"flamme.section.TemporalNullValueSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalNullValueSection.period","title":"flamme.section.TemporalNullValueSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection","title":"flamme.section.TemporalRowCountSection","text":"<p>               Bases: <code>BaseSection</code></p> <p>Implement a section to analyze the number of rows per temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>dt_column</code> <code>str</code> <p>The datetime column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>figsize</code> <code>tuple[float, float] | None</code> <p>The figure size in inches. The first dimension is the width and the second is the height.</p> <code>None</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; from flamme.section import TemporalRowCountSection\n&gt;&gt;&gt; section = TemporalRowCountSection(\n...     frame=pd.DataFrame(\n...         {\n...             \"datetime\": pd.to_datetime(\n...                 [\n...                     \"2020-01-03\",\n...                     \"2020-01-04\",\n...                     \"2020-01-05\",\n...                     \"2020-02-03\",\n...                     \"2020-03-03\",\n...                     \"2020-04-03\",\n...                 ]\n...             )\n...         }\n...     ),\n...     dt_column=\"datetime\",\n...     period=\"M\",\n... )\n&gt;&gt;&gt; section\nTemporalRowCountSection(dt_column=datetime, period=M, figsize=None)\n&gt;&gt;&gt; section.get_statistics()\n{}\n</code></pre>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.dt_column","title":"flamme.section.TemporalRowCountSection.dt_column  <code>property</code>","text":"<pre><code>dt_column: str\n</code></pre> <p>The datetime column.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.figsize","title":"flamme.section.TemporalRowCountSection.figsize  <code>property</code>","text":"<pre><code>figsize: tuple[float, float] | None\n</code></pre> <p>The individual figure size in pixels.</p> <p>The first dimension is the width and the second is the height.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.frame","title":"flamme.section.TemporalRowCountSection.frame  <code>property</code>","text":"<pre><code>frame: DataFrame\n</code></pre> <p>The DataFrame to analyze.</p>"},{"location":"refs/section/#flamme.section.TemporalRowCountSection.period","title":"flamme.section.TemporalRowCountSection.period  <code>property</code>","text":"<pre><code>period: str\n</code></pre> <p>The temporal period used to analyze the data.</p>"},{"location":"refs/transformer/","title":"transformer","text":""},{"location":"refs/transformer/#flamme.transformer","title":"flamme.transformer","text":"<p>Contain transformers.</p>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#flamme.utils","title":"flamme.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#flamme.utils.setup_object","title":"flamme.utils.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from flamme.utils import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"}]}